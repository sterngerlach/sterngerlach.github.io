<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="SternGerlach" />
  <title>分枝限定法によるスキャンマッチング(実装編)</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">分枝限定法によるスキャンマッチング(実装編)</h1>
<p class="author">SternGerlach</p>
</header>
<!--
 pandoc -s --filter pandoc-crossref -M "crossrefYaml=./crossref_config.yaml" -f markdown -t html5 --mathjax --css style.css scan-matching-branch-and-bound-impl.md > scan-matching-branch-and-bound-impl.html
-->
<p><a href="./index.html">ホームに戻る</a></p>
<h1 id="このページについて">このページについて</h1>
<p>このページは、慶應理工アドベントカレンダー2021の15日目の記事です。</p>
<p><a href="./scan-matching-branch-and-bound.html">こちらのページ</a>の続きです。 分枝限定法によるスキャンマッチングのPythonによる実装を示します。 Pythonの実装は<a href="https://github.com/sterngerlach/scan_matcher_2d_python">GitHubのリポジトリ</a>に置かれています(中の人が1から作っています)。</p>
<h2 id="次元の姿勢と位置">2次元の姿勢と位置</h2>
<p>2次元の姿勢を<code>Pose2D</code>クラス、2次元の位置を<code>Point2D</code>クラスとして次のように定義します。 <code>Pose2D</code>クラスのソースコードは<a href="https://github.com/sterngerlach/scan_matcher_2d_python/blob/master/pose_2d.py">こちら</a>、<code>Point2D</code>クラスのソースコードは<a href="https://github.com/sterngerlach/scan_matcher_2d_python/blob/master/point_2d.py">こちら</a>を参照してください。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Point2D(<span class="bu">object</span>):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.y <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, x: <span class="bu">float</span>, y: <span class="bu">float</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x <span class="op">=</span> x</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.y <span class="op">=</span> y</span></code></pre></div>
<p><code>project_point_2d()</code>関数は、ある姿勢のもとで、点の座標を変換します。 姿勢は引数<code>pose</code>、点の座標は引数<code>point</code>にそれぞれ指定します。 例えば、<code>pose</code>がロボットの姿勢(地図座標系からLiDAR座標系への座標変換)、<code>point</code>がLiDAR座標系におけるスキャン点の座標(直交座標)であれば、地図座標系におけるスキャン点の座標が返されます。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Pose2D(<span class="bu">object</span>):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.y <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.theta <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, x: <span class="bu">float</span>, y: <span class="bu">float</span>, theta: <span class="bu">float</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x <span class="op">=</span> x</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.y <span class="op">=</span> y</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.theta <span class="op">=</span> theta</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> project_point_2d(pose: Pose2D, point: Point2D) <span class="op">-&gt;</span> Point2D:</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Project a 2D point using a 2D pose&quot;&quot;&quot;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    sin_theta <span class="op">=</span> math.sin(pose.theta)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    cos_theta <span class="op">=</span> math.cos(pose.theta)</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> pose.x <span class="op">+</span> cos_theta <span class="op">*</span> point.x <span class="op">-</span> sin_theta <span class="op">*</span> point.y</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> pose.y <span class="op">+</span> sin_theta <span class="op">*</span> point.x <span class="op">+</span> cos_theta <span class="op">*</span> point.y</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Point2D(x, y)</span></code></pre></div>
<h2 id="占有格子地図の実装">占有格子地図の実装</h2>
<p>占有格子地図(Occupancy Grid Map)の実装(<code>Grid2D</code>クラス)を示します。 <code>Grid2D</code>クラスのソースコードは<a href="https://github.com/sterngerlach/scan_matcher_2d_python/blob/master/grid_2d.py">こちら</a>を参照してください。 重要な部分だけを以下に列挙します。</p>
<ul>
<li>占有格子地図は、解像度、中心の座標、<span class="math inline">\(x\)</span>と<span class="math inline">\(y\)</span>方向の格子の数で定義されます。 解像度は<code>resolution()</code>メソッド、中心の座標は<code>center_pos()</code>メソッド、左下端(<span class="math inline">\((0, 0)\)</span>番目の格子)の座標は<code>min_pos()</code>メソッド、<span class="math inline">\(x\)</span>と<span class="math inline">\(y\)</span>方向の格子の数は<code>num_of_cells_x()</code>、<code>num_of_cells_y()</code>メソッドからそれぞれ取得できます。</li>
<li>各格子の占有確率は、16ビットの整数(1から65535まで)に量子化したうえで、リストに格納されます。 格子は<span class="math inline">\(x\)</span>と<span class="math inline">\(y\)</span>の2つのインデックスで表せますが、<code>flat_index()</code>メソッドによって、リストにアクセスするための1次元のインデックスに変換できます。 分枝限定法によるスキャンマッチングの際は、占有確率の総和を取る必要があります。 占有確率が16ビット整数に量子化されているので、浮動小数点数の総和が整数の総和に置き換わって、多少の高速化を期待できます。</li>
<li><code>index_to_point()</code>メソッドは、指定された格子に対応する座標を返します。 <code>point_to_index()</code>メソッドはその逆で、指定された位置に対応する格子のインデックスを返します。</li>
<li><code>get_index_value()</code>と<code>get_index_probability()</code>メソッドは、指定された格子の占有確率を、16ビットの整数、あるいは浮動小数点数で返します。</li>
<li><code>compute_coarse_map()</code>関数は、<a href="./scan-matching-branch-and-bound.html">以前のページ</a>における<span class="math inline">\(\mathcal{M}_\mathrm{precomp}^h\)</span>を計算します。 引数<code>win_size</code>に<span class="math inline">\(2^h\)</span>、<code>grid_map</code>に占有格子地図<span class="math inline">\(\mathcal{M}\)</span>を指定します。 計算にあたっては、占有確率の比較が繰り返し必要です。 占有確率が16ビット整数に量子化されているので、浮動小数点数の比較が整数の比較に置き換わって、多少の高速化を期待できます。 <span class="math display">\[
\mathcal{M}_\mathrm{precomp}^h(i, j)
= \max_{\substack{i \le i&#39; &lt; i + 2^h \\ j \le j&#39; &lt; j + 2^h}} \mathcal{M}(i&#39;, j&#39;)
\]</span></li>
<li>ここでは使っていませんが、地図の更新に必要な各種メソッドも定義されているので、興味があれば読んでみてください。 格子がもつ占有確率の更新には、バイナリベイズフィルタを利用します。 また、LiDARセンサの中心と各スキャン点を結ぶ直線を考え、その直線上を通過する格子のインデックスを計算するために、ブレゼンハムのアルゴリズムを利用します。</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># coding: utf-8</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co"># grid_2d.py</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Callable, List, Tuple</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> point_2d <span class="im">import</span> Point2D</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pose_2d <span class="im">import</span> Pose2D, project_point_2d</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> util <span class="im">import</span> bresenham</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> probability_to_value(x: <span class="bu">float</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">int</span>(x <span class="op">*</span> <span class="fl">65536.0</span>)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> value_to_probability(x: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">float</span>(x) <span class="op">/</span> <span class="fl">65536.0</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> probability_to_log_odds(x: <span class="bu">float</span>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> math.log(x <span class="op">/</span> (<span class="fl">1.0</span> <span class="op">-</span> x))</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> log_odds_to_probability(x: <span class="bu">float</span>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fl">1.0</span> <span class="op">/</span> (<span class="fl">1.0</span> <span class="op">+</span> math.exp(<span class="op">-</span>x))</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> probability_to_odds(x: <span class="bu">float</span>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">/</span> (<span class="fl">1.0</span> <span class="op">-</span> x)</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> odds_to_probability(x: <span class="bu">float</span>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">/</span> (<span class="fl">1.0</span> <span class="op">+</span> x)</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> log_odds_to_value(x: <span class="bu">float</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> probability_to_value(log_odds_to_probability(x))</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> value_to_log_odds(x: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> probability_to_log_odds(value_to_probability(x))</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> probability_to_grayscale(x: <span class="bu">float</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">255</span> <span class="op">-</span> <span class="bu">int</span>(x <span class="op">*</span> <span class="fl">255.0</span>)</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> value_to_grayscale(x: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">255</span> <span class="op">-</span> (x <span class="op">&gt;&gt;</span> <span class="dv">8</span>)</span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Grid2D(<span class="bu">object</span>):</span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Grid2D class represents a simple 2D grid map. Each grid cell contains</span></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a><span class="co">    a quantized occupancy probability, which is incrementally updated by</span></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a><span class="co">    Binary Bayes Filter.&quot;&quot;&quot;</span></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>    VALUE_MIN <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>    VALUE_MAX <span class="op">=</span> <span class="dv">65535</span></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>    PROBABILITY_MIN <span class="op">=</span> value_to_probability(VALUE_MIN)</span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>    PROBABILITY_MAX <span class="op">=</span> value_to_probability(VALUE_MAX)</span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>    LOG_ODDS_MIN <span class="op">=</span> probability_to_log_odds(PROBABILITY_MIN)</span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>    LOG_ODDS_MAX <span class="op">=</span> probability_to_log_odds(PROBABILITY_MAX)</span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, resolution: <span class="bu">float</span>, center_x: <span class="bu">float</span>, center_y: <span class="bu">float</span>,</span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a>                 num_of_cells_x: <span class="bu">int</span>, num_of_cells_y: <span class="bu">int</span>,</span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a>                 log_odds_hit: <span class="bu">float</span>, log_odds_miss: <span class="bu">float</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> num_of_cells_x <span class="op">&gt;</span> <span class="dv">0</span></span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> num_of_cells_y <span class="op">&gt;</span> <span class="dv">0</span></span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> Grid2D.LOG_ODDS_MIN <span class="op">&lt;=</span> log_odds_miss <span class="op">&lt;=</span> Grid2D.LOG_ODDS_MAX</span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> Grid2D.LOG_ODDS_MIN <span class="op">&lt;=</span> log_odds_hit <span class="op">&lt;=</span> Grid2D.LOG_ODDS_MAX</span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__resolution <span class="op">=</span> resolution</span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__min_x <span class="op">=</span> center_x <span class="op">-</span> resolution <span class="op">*</span> num_of_cells_x <span class="op">/</span> <span class="fl">2.0</span></span>
<span id="cb3-65"><a href="#cb3-65" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__min_y <span class="op">=</span> center_y <span class="op">-</span> resolution <span class="op">*</span> num_of_cells_y <span class="op">/</span> <span class="fl">2.0</span></span>
<span id="cb3-66"><a href="#cb3-66" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__center_x <span class="op">=</span> center_x</span>
<span id="cb3-67"><a href="#cb3-67" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__center_y <span class="op">=</span> center_y</span>
<span id="cb3-68"><a href="#cb3-68" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__num_of_cells_x <span class="op">=</span> num_of_cells_x</span>
<span id="cb3-69"><a href="#cb3-69" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__num_of_cells_y <span class="op">=</span> num_of_cells_y</span>
<span id="cb3-70"><a href="#cb3-70" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__log_odds_miss <span class="op">=</span> log_odds_miss</span>
<span id="cb3-71"><a href="#cb3-71" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__log_odds_hit <span class="op">=</span> log_odds_hit</span>
<span id="cb3-72"><a href="#cb3-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-73"><a href="#cb3-73" aria-hidden="true" tabindex="-1"></a>        num_of_cells <span class="op">=</span> num_of_cells_x <span class="op">*</span> num_of_cells_y</span>
<span id="cb3-74"><a href="#cb3-74" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__values <span class="op">=</span> [Grid2D.VALUE_MIN <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_of_cells)]</span>
<span id="cb3-75"><a href="#cb3-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-76"><a href="#cb3-76" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> resolution(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb3-77"><a href="#cb3-77" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.__resolution</span>
<span id="cb3-78"><a href="#cb3-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-79"><a href="#cb3-79" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> num_of_cells_x(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb3-80"><a href="#cb3-80" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.__num_of_cells_x</span>
<span id="cb3-81"><a href="#cb3-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-82"><a href="#cb3-82" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> num_of_cells_y(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb3-83"><a href="#cb3-83" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.__num_of_cells_y</span>
<span id="cb3-84"><a href="#cb3-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-85"><a href="#cb3-85" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> log_odds_miss(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb3-86"><a href="#cb3-86" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.__log_odds_miss</span>
<span id="cb3-87"><a href="#cb3-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-88"><a href="#cb3-88" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> log_odds_hit(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb3-89"><a href="#cb3-89" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.__log_odds_hit</span>
<span id="cb3-90"><a href="#cb3-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-91"><a href="#cb3-91" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> shape(<span class="va">self</span>) <span class="op">-&gt;</span> Tuple[<span class="bu">int</span>, <span class="bu">int</span>]:</span>
<span id="cb3-92"><a href="#cb3-92" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.__num_of_cells_x, <span class="va">self</span>.__num_of_cells_y</span>
<span id="cb3-93"><a href="#cb3-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-94"><a href="#cb3-94" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> min_pos(<span class="va">self</span>) <span class="op">-&gt;</span> Tuple[<span class="bu">float</span>, <span class="bu">float</span>]:</span>
<span id="cb3-95"><a href="#cb3-95" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.__min_x, <span class="va">self</span>.__min_y</span>
<span id="cb3-96"><a href="#cb3-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-97"><a href="#cb3-97" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> center_pos(<span class="va">self</span>) <span class="op">-&gt;</span> Tuple[<span class="bu">float</span>, <span class="bu">float</span>]:</span>
<span id="cb3-98"><a href="#cb3-98" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.__center_x, <span class="va">self</span>.__center_y</span>
<span id="cb3-99"><a href="#cb3-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-100"><a href="#cb3-100" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> flat_index(<span class="va">self</span>, x: <span class="bu">int</span>, y: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb3-101"><a href="#cb3-101" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> y <span class="op">*</span> <span class="va">self</span>.__num_of_cells_x <span class="op">+</span> x</span>
<span id="cb3-102"><a href="#cb3-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-103"><a href="#cb3-103" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> is_index_inside(<span class="va">self</span>, x: <span class="bu">int</span>, y: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb3-104"><a href="#cb3-104" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span> <span class="op">&lt;=</span> x <span class="op">&lt;</span> <span class="va">self</span>.__num_of_cells_x <span class="kw">and</span> <span class="op">\</span></span>
<span id="cb3-105"><a href="#cb3-105" aria-hidden="true" tabindex="-1"></a>               <span class="dv">0</span> <span class="op">&lt;=</span> y <span class="op">&lt;</span> <span class="va">self</span>.__num_of_cells_y</span>
<span id="cb3-106"><a href="#cb3-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-107"><a href="#cb3-107" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> is_point_inside(<span class="va">self</span>, p: Point2D) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb3-108"><a href="#cb3-108" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.is_index_inside(<span class="op">*</span><span class="va">self</span>.point_to_index(p))</span>
<span id="cb3-109"><a href="#cb3-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-110"><a href="#cb3-110" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> index_to_point(<span class="va">self</span>, x: <span class="bu">int</span>, y: <span class="bu">int</span>) <span class="op">-&gt;</span> Point2D:</span>
<span id="cb3-111"><a href="#cb3-111" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Compute the minimum coordinates in the map frame&quot;&quot;&quot;</span></span>
<span id="cb3-112"><a href="#cb3-112" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Point2D(<span class="va">self</span>.__min_x <span class="op">+</span> x <span class="op">*</span> <span class="va">self</span>.__resolution,</span>
<span id="cb3-113"><a href="#cb3-113" aria-hidden="true" tabindex="-1"></a>                       <span class="va">self</span>.__min_y <span class="op">+</span> y <span class="op">*</span> <span class="va">self</span>.__resolution)</span>
<span id="cb3-114"><a href="#cb3-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-115"><a href="#cb3-115" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> point_to_index(<span class="va">self</span>, p: Point2D) <span class="op">-&gt;</span> Tuple[<span class="bu">int</span>, <span class="bu">int</span>]:</span>
<span id="cb3-116"><a href="#cb3-116" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Compute the index from the coordinates in the map frame&quot;&quot;&quot;</span></span>
<span id="cb3-117"><a href="#cb3-117" aria-hidden="true" tabindex="-1"></a>        idx_x <span class="op">=</span> <span class="bu">int</span>((p.x <span class="op">-</span> <span class="va">self</span>.__min_x) <span class="op">//</span> <span class="va">self</span>.__resolution)</span>
<span id="cb3-118"><a href="#cb3-118" aria-hidden="true" tabindex="-1"></a>        idx_y <span class="op">=</span> <span class="bu">int</span>((p.y <span class="op">-</span> <span class="va">self</span>.__min_y) <span class="op">//</span> <span class="va">self</span>.__resolution)</span>
<span id="cb3-119"><a href="#cb3-119" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> idx_x <span class="cf">if</span> p.x <span class="op">&gt;=</span> <span class="va">self</span>.__min_x <span class="cf">else</span> idx_x <span class="op">-</span> <span class="dv">1</span>, <span class="op">\</span></span>
<span id="cb3-120"><a href="#cb3-120" aria-hidden="true" tabindex="-1"></a>               idx_y <span class="cf">if</span> p.y <span class="op">&gt;=</span> <span class="va">self</span>.__min_y <span class="cf">else</span> idx_y <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb3-121"><a href="#cb3-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-122"><a href="#cb3-122" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> point_to_index_float(<span class="va">self</span>, p: Point2D) <span class="op">-&gt;</span> Tuple[<span class="bu">float</span>, <span class="bu">float</span>]:</span>
<span id="cb3-123"><a href="#cb3-123" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Compute the index in the floating point in the map frame&quot;&quot;&quot;</span></span>
<span id="cb3-124"><a href="#cb3-124" aria-hidden="true" tabindex="-1"></a>        idx_x <span class="op">=</span> (p.x <span class="op">-</span> <span class="va">self</span>.__min_x) <span class="op">/</span> <span class="va">self</span>.__resolution</span>
<span id="cb3-125"><a href="#cb3-125" aria-hidden="true" tabindex="-1"></a>        idx_y <span class="op">=</span> (p.y <span class="op">-</span> <span class="va">self</span>.__min_y) <span class="op">/</span> <span class="va">self</span>.__resolution</span>
<span id="cb3-126"><a href="#cb3-126" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> idx_x, idx_y</span>
<span id="cb3-127"><a href="#cb3-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-128"><a href="#cb3-128" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_index_value(<span class="va">self</span>, x: <span class="bu">int</span>, y: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb3-129"><a href="#cb3-129" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> <span class="va">self</span>.is_index_inside(x, y)</span>
<span id="cb3-130"><a href="#cb3-130" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.__values[<span class="va">self</span>.flat_index(x, y)]</span>
<span id="cb3-131"><a href="#cb3-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-132"><a href="#cb3-132" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_index_probability(<span class="va">self</span>, x: <span class="bu">int</span>, y: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb3-133"><a href="#cb3-133" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> <span class="va">self</span>.is_index_inside(x, y)</span>
<span id="cb3-134"><a href="#cb3-134" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> value_to_probability(<span class="va">self</span>.__values[<span class="va">self</span>.flat_index(x, y)])</span>
<span id="cb3-135"><a href="#cb3-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-136"><a href="#cb3-136" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_point_value(<span class="va">self</span>, p: Point2D) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb3-137"><a href="#cb3-137" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.get_index_value(<span class="op">*</span><span class="va">self</span>.point_to_index(p))</span>
<span id="cb3-138"><a href="#cb3-138" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-139"><a href="#cb3-139" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_point_probability(<span class="va">self</span>, p: Point2D) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb3-140"><a href="#cb3-140" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.get_index_probability(<span class="op">*</span><span class="va">self</span>.point_to_index(p))</span>
<span id="cb3-141"><a href="#cb3-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-142"><a href="#cb3-142" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_neighbor_probabilities(<span class="va">self</span>, p: Point2D):</span>
<span id="cb3-143"><a href="#cb3-143" aria-hidden="true" tabindex="-1"></a>        x, y <span class="op">=</span> <span class="va">self</span>.point_to_index_float(p)</span>
<span id="cb3-144"><a href="#cb3-144" aria-hidden="true" tabindex="-1"></a>        x0, y0 <span class="op">=</span> <span class="bu">int</span>(x), <span class="bu">int</span>(y)</span>
<span id="cb3-145"><a href="#cb3-145" aria-hidden="true" tabindex="-1"></a>        x1, y1 <span class="op">=</span> x0 <span class="op">+</span> <span class="dv">1</span>, y0 <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb3-146"><a href="#cb3-146" aria-hidden="true" tabindex="-1"></a>        dx, dy <span class="op">=</span> x <span class="op">-</span> x0, y <span class="op">-</span> y0</span>
<span id="cb3-147"><a href="#cb3-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-148"><a href="#cb3-148" aria-hidden="true" tabindex="-1"></a>        x0_valid <span class="op">=</span> <span class="dv">0</span> <span class="op">&lt;=</span> x0 <span class="op">&lt;</span> <span class="va">self</span>.__num_of_cells_x</span>
<span id="cb3-149"><a href="#cb3-149" aria-hidden="true" tabindex="-1"></a>        x1_valid <span class="op">=</span> <span class="dv">0</span> <span class="op">&lt;=</span> x1 <span class="op">&lt;</span> <span class="va">self</span>.__num_of_cells_x</span>
<span id="cb3-150"><a href="#cb3-150" aria-hidden="true" tabindex="-1"></a>        y0_valid <span class="op">=</span> <span class="dv">0</span> <span class="op">&lt;=</span> y0 <span class="op">&lt;</span> <span class="va">self</span>.__num_of_cells_y</span>
<span id="cb3-151"><a href="#cb3-151" aria-hidden="true" tabindex="-1"></a>        y1_valid <span class="op">=</span> <span class="dv">0</span> <span class="op">&lt;=</span> y1 <span class="op">&lt;</span> <span class="va">self</span>.__num_of_cells_y</span>
<span id="cb3-152"><a href="#cb3-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-153"><a href="#cb3-153" aria-hidden="true" tabindex="-1"></a>        m00 <span class="op">=</span> <span class="va">self</span>.get_index_probability(x0, y0) <span class="op">\</span></span>
<span id="cb3-154"><a href="#cb3-154" aria-hidden="true" tabindex="-1"></a>              <span class="cf">if</span> x0_valid <span class="kw">and</span> y0_valid <span class="cf">else</span> <span class="fl">0.5</span></span>
<span id="cb3-155"><a href="#cb3-155" aria-hidden="true" tabindex="-1"></a>        m01 <span class="op">=</span> <span class="va">self</span>.get_index_probability(x0, y1) <span class="op">\</span></span>
<span id="cb3-156"><a href="#cb3-156" aria-hidden="true" tabindex="-1"></a>              <span class="cf">if</span> x0_valid <span class="kw">and</span> y1_valid <span class="cf">else</span> <span class="fl">0.5</span></span>
<span id="cb3-157"><a href="#cb3-157" aria-hidden="true" tabindex="-1"></a>        m10 <span class="op">=</span> <span class="va">self</span>.get_index_probability(x1, y0) <span class="op">\</span></span>
<span id="cb3-158"><a href="#cb3-158" aria-hidden="true" tabindex="-1"></a>              <span class="cf">if</span> x1_valid <span class="kw">and</span> y0_valid <span class="cf">else</span> <span class="fl">0.5</span></span>
<span id="cb3-159"><a href="#cb3-159" aria-hidden="true" tabindex="-1"></a>        m11 <span class="op">=</span> <span class="va">self</span>.get_index_probability(x1, y1) <span class="op">\</span></span>
<span id="cb3-160"><a href="#cb3-160" aria-hidden="true" tabindex="-1"></a>              <span class="cf">if</span> x1_valid <span class="kw">and</span> y1_valid <span class="cf">else</span> <span class="fl">0.5</span></span>
<span id="cb3-161"><a href="#cb3-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-162"><a href="#cb3-162" aria-hidden="true" tabindex="-1"></a>        interpolated <span class="op">=</span> dy <span class="op">*</span> (dx <span class="op">*</span> m11 <span class="op">+</span> (<span class="fl">1.0</span> <span class="op">-</span> dx) <span class="op">*</span> m01) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb3-163"><a href="#cb3-163" aria-hidden="true" tabindex="-1"></a>                       (<span class="fl">1.0</span> <span class="op">-</span> dy) <span class="op">*</span> (dx <span class="op">*</span> m10 <span class="op">+</span> (<span class="fl">1.0</span> <span class="op">-</span> dx) <span class="op">*</span> m00)</span>
<span id="cb3-164"><a href="#cb3-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-165"><a href="#cb3-165" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (x0, y0), (dx, dy), (m00, m01, m10, m11), interpolated</span>
<span id="cb3-166"><a href="#cb3-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-167"><a href="#cb3-167" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_interpolated_probability(<span class="va">self</span>, p: Point2D) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb3-168"><a href="#cb3-168" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.get_neighbor_probabilities(p)[<span class="dv">3</span>]</span>
<span id="cb3-169"><a href="#cb3-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-170"><a href="#cb3-170" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> set_index_value(<span class="va">self</span>, x: <span class="bu">int</span>, y: <span class="bu">int</span>, value: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb3-171"><a href="#cb3-171" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> <span class="va">self</span>.is_index_inside(x, y)</span>
<span id="cb3-172"><a href="#cb3-172" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__values[<span class="va">self</span>.flat_index(x, y)] <span class="op">=</span> <span class="va">self</span>.__clamp_value(value)</span>
<span id="cb3-173"><a href="#cb3-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-174"><a href="#cb3-174" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> set_index_probability(<span class="va">self</span>, x: <span class="bu">int</span>, y: <span class="bu">int</span>, value: <span class="bu">float</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb3-175"><a href="#cb3-175" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> <span class="va">self</span>.is_index_inside(x, y)</span>
<span id="cb3-176"><a href="#cb3-176" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__values[<span class="va">self</span>.flat_index(x, y)] <span class="op">=</span> <span class="op">\</span></span>
<span id="cb3-177"><a href="#cb3-177" aria-hidden="true" tabindex="-1"></a>             <span class="va">self</span>.__clamp_value(probability_to_value(value))</span>
<span id="cb3-178"><a href="#cb3-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-179"><a href="#cb3-179" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> set_point_value(<span class="va">self</span>, p: Point2D, value: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb3-180"><a href="#cb3-180" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.set_index_value(<span class="op">*</span><span class="va">self</span>.point_to_index(p), value)</span>
<span id="cb3-181"><a href="#cb3-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-182"><a href="#cb3-182" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> set_point_probability(<span class="va">self</span>, p: Point2D, value: <span class="bu">float</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb3-183"><a href="#cb3-183" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.set_index_probability(<span class="op">*</span><span class="va">self</span>.point_to_index(p), value)</span>
<span id="cb3-184"><a href="#cb3-184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-185"><a href="#cb3-185" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> __update_index_log_odds(<span class="va">self</span>, x: <span class="bu">int</span>, y: <span class="bu">int</span>, value: <span class="bu">float</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb3-186"><a href="#cb3-186" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> <span class="va">self</span>.is_index_inside(x, y)</span>
<span id="cb3-187"><a href="#cb3-187" aria-hidden="true" tabindex="-1"></a>        idx <span class="op">=</span> <span class="va">self</span>.flat_index(x, y)</span>
<span id="cb3-188"><a href="#cb3-188" aria-hidden="true" tabindex="-1"></a>        log_odds <span class="op">=</span> value_to_log_odds(<span class="va">self</span>.__values[idx]) <span class="op">+</span> value</span>
<span id="cb3-189"><a href="#cb3-189" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__values[idx] <span class="op">=</span> <span class="va">self</span>.__clamp_value(log_odds_to_value(log_odds))</span>
<span id="cb3-190"><a href="#cb3-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-191"><a href="#cb3-191" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> update_index_hit(<span class="va">self</span>, x: <span class="bu">int</span>, y: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb3-192"><a href="#cb3-192" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__update_index_log_odds(x, y, <span class="va">self</span>.__log_odds_hit)</span>
<span id="cb3-193"><a href="#cb3-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-194"><a href="#cb3-194" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> update_index_miss(<span class="va">self</span>, x: <span class="bu">int</span>, y: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb3-195"><a href="#cb3-195" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__update_index_log_odds(x, y, <span class="va">self</span>.__log_odds_miss)</span>
<span id="cb3-196"><a href="#cb3-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-197"><a href="#cb3-197" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> update_point_hit(<span class="va">self</span>, p: Point2D) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb3-198"><a href="#cb3-198" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.update_index_hit(<span class="op">*</span><span class="va">self</span>.point_to_index(p))</span>
<span id="cb3-199"><a href="#cb3-199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-200"><a href="#cb3-200" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> update_point_miss(<span class="va">self</span>, p: Point2D) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb3-201"><a href="#cb3-201" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.update_index_miss(<span class="op">*</span><span class="va">self</span>.point_to_index(p))</span>
<span id="cb3-202"><a href="#cb3-202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-203"><a href="#cb3-203" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> update_from_scans(<span class="va">self</span>, pose: Pose2D, scan: List[Point2D]) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb3-204"><a href="#cb3-204" aria-hidden="true" tabindex="-1"></a>        pose_idx <span class="op">=</span> <span class="va">self</span>.point_to_index(Point2D(pose.x, pose.y))</span>
<span id="cb3-205"><a href="#cb3-205" aria-hidden="true" tabindex="-1"></a>        points <span class="op">=</span> [project_point_2d(pose, p) <span class="cf">for</span> p <span class="kw">in</span> scan]</span>
<span id="cb3-206"><a href="#cb3-206" aria-hidden="true" tabindex="-1"></a>        scan_indices <span class="op">=</span> [<span class="va">self</span>.point_to_index(p) <span class="cf">for</span> p <span class="kw">in</span> points]</span>
<span id="cb3-207"><a href="#cb3-207" aria-hidden="true" tabindex="-1"></a>        ray_indices <span class="op">=</span> [bresenham(<span class="op">*</span>pose_idx, <span class="op">*</span>idx) <span class="cf">for</span> idx <span class="kw">in</span> scan_indices]</span>
<span id="cb3-208"><a href="#cb3-208" aria-hidden="true" tabindex="-1"></a>        <span class="co"># hit_indices = [indices[-1] for indices in ray_indices]</span></span>
<span id="cb3-209"><a href="#cb3-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-210"><a href="#cb3-210" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> indices <span class="kw">in</span> ray_indices:</span>
<span id="cb3-211"><a href="#cb3-211" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> missed_idx <span class="kw">in</span> indices[:<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb3-212"><a href="#cb3-212" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="va">self</span>.is_index_inside(<span class="op">*</span>missed_idx):</span>
<span id="cb3-213"><a href="#cb3-213" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.update_index_miss(<span class="op">*</span>missed_idx)</span>
<span id="cb3-214"><a href="#cb3-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-215"><a href="#cb3-215" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.is_index_inside(<span class="op">*</span>indices[<span class="op">-</span><span class="dv">1</span>]):</span>
<span id="cb3-216"><a href="#cb3-216" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.update_index_hit(<span class="op">*</span>indices[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb3-217"><a href="#cb3-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-218"><a href="#cb3-218" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> __clamp_value(<span class="va">self</span>, x: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb3-219"><a href="#cb3-219" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">max</span>(Grid2D.VALUE_MIN, <span class="bu">min</span>(Grid2D.VALUE_MAX, x))</span>
<span id="cb3-220"><a href="#cb3-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-221"><a href="#cb3-221" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> to_bytes(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="bu">bytes</span>:</span>
<span id="cb3-222"><a href="#cb3-222" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">bytes</span>([value_to_grayscale(x) <span class="cf">for</span> x <span class="kw">in</span> <span class="va">self</span>.__values])</span>
<span id="cb3-223"><a href="#cb3-223" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-224"><a href="#cb3-224" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sliding_window_max(in_func: Callable[[<span class="bu">int</span>], <span class="bu">int</span>],</span>
<span id="cb3-225"><a href="#cb3-225" aria-hidden="true" tabindex="-1"></a>                       out_func: Callable[[<span class="bu">int</span>, <span class="bu">int</span>], <span class="va">None</span>],</span>
<span id="cb3-226"><a href="#cb3-226" aria-hidden="true" tabindex="-1"></a>                       num_of_elements: <span class="bu">int</span>, win_size: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb3-227"><a href="#cb3-227" aria-hidden="true" tabindex="-1"></a>    idx_queue, idx_in, idx_out <span class="op">=</span> deque(), <span class="dv">0</span>, <span class="dv">0</span></span>
<span id="cb3-228"><a href="#cb3-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-229"><a href="#cb3-229" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Process the first `win_size` elements (first window)</span></span>
<span id="cb3-230"><a href="#cb3-230" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> idx_in <span class="op">&lt;</span> win_size:</span>
<span id="cb3-231"><a href="#cb3-231" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Previous smaller elements are useless so remove them from `idx_queue`</span></span>
<span id="cb3-232"><a href="#cb3-232" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> idx_queue <span class="kw">and</span> in_func(idx_in) <span class="op">&gt;=</span> in_func(idx_queue[<span class="op">-</span><span class="dv">1</span>]):</span>
<span id="cb3-233"><a href="#cb3-233" aria-hidden="true" tabindex="-1"></a>            idx_queue.pop()</span>
<span id="cb3-234"><a href="#cb3-234" aria-hidden="true" tabindex="-1"></a>        idx_queue.append(idx_in)</span>
<span id="cb3-235"><a href="#cb3-235" aria-hidden="true" tabindex="-1"></a>        idx_in <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-236"><a href="#cb3-236" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-237"><a href="#cb3-237" aria-hidden="true" tabindex="-1"></a>    <span class="co"># `idx_queue[0]` contains index of the maximum element in the first window</span></span>
<span id="cb3-238"><a href="#cb3-238" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Process the rest of the elements here</span></span>
<span id="cb3-239"><a href="#cb3-239" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> idx_in <span class="op">&lt;</span> num_of_elements:</span>
<span id="cb3-240"><a href="#cb3-240" aria-hidden="true" tabindex="-1"></a>        <span class="co"># The element pointed by the `idx_queue[0]` is the maximum element of</span></span>
<span id="cb3-241"><a href="#cb3-241" aria-hidden="true" tabindex="-1"></a>        <span class="co"># the previous window</span></span>
<span id="cb3-242"><a href="#cb3-242" aria-hidden="true" tabindex="-1"></a>        out_func(idx_out, in_func(idx_queue[<span class="dv">0</span>]))</span>
<span id="cb3-243"><a href="#cb3-243" aria-hidden="true" tabindex="-1"></a>        idx_out <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-244"><a href="#cb3-244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-245"><a href="#cb3-245" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Remove the elements that are out of the current window</span></span>
<span id="cb3-246"><a href="#cb3-246" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> idx_queue <span class="kw">and</span> idx_queue[<span class="dv">0</span>] <span class="op">&lt;=</span> idx_in <span class="op">-</span> win_size:</span>
<span id="cb3-247"><a href="#cb3-247" aria-hidden="true" tabindex="-1"></a>            idx_queue.popleft()</span>
<span id="cb3-248"><a href="#cb3-248" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-249"><a href="#cb3-249" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Remove all elements smaller than the current element</span></span>
<span id="cb3-250"><a href="#cb3-250" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> idx_queue <span class="kw">and</span> in_func(idx_in) <span class="op">&gt;=</span> in_func(idx_queue[<span class="op">-</span><span class="dv">1</span>]):</span>
<span id="cb3-251"><a href="#cb3-251" aria-hidden="true" tabindex="-1"></a>            idx_queue.pop()</span>
<span id="cb3-252"><a href="#cb3-252" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-253"><a href="#cb3-253" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Append the current element to `idx_queue`</span></span>
<span id="cb3-254"><a href="#cb3-254" aria-hidden="true" tabindex="-1"></a>        idx_queue.append(idx_in)</span>
<span id="cb3-255"><a href="#cb3-255" aria-hidden="true" tabindex="-1"></a>        idx_in <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-256"><a href="#cb3-256" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-257"><a href="#cb3-257" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Repeat the last elements</span></span>
<span id="cb3-258"><a href="#cb3-258" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> idx_out <span class="op">&lt;</span> num_of_elements:</span>
<span id="cb3-259"><a href="#cb3-259" aria-hidden="true" tabindex="-1"></a>        out_func(idx_out, in_func(idx_queue[<span class="dv">0</span>]))</span>
<span id="cb3-260"><a href="#cb3-260" aria-hidden="true" tabindex="-1"></a>        idx_out <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-261"><a href="#cb3-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-262"><a href="#cb3-262" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_coarse_map_slow(grid_map: Grid2D, win_size: <span class="bu">int</span>) <span class="op">-&gt;</span> Grid2D:</span>
<span id="cb3-263"><a href="#cb3-263" aria-hidden="true" tabindex="-1"></a>    num_of_cells <span class="op">=</span> grid_map.num_of_cells_x() <span class="op">*</span> grid_map.num_of_cells_y()</span>
<span id="cb3-264"><a href="#cb3-264" aria-hidden="true" tabindex="-1"></a>    <span class="bu">buffer</span> <span class="op">=</span> [<span class="dv">0</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_of_cells)]</span>
<span id="cb3-265"><a href="#cb3-265" aria-hidden="true" tabindex="-1"></a>    coarse_map <span class="op">=</span> Grid2D(grid_map.resolution(), <span class="op">*</span>grid_map.center_pos(),</span>
<span id="cb3-266"><a href="#cb3-266" aria-hidden="true" tabindex="-1"></a>                        grid_map.num_of_cells_x(), grid_map.num_of_cells_y(),</span>
<span id="cb3-267"><a href="#cb3-267" aria-hidden="true" tabindex="-1"></a>                        grid_map.log_odds_hit(), grid_map.log_odds_miss())</span>
<span id="cb3-268"><a href="#cb3-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-269"><a href="#cb3-269" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_buffer(idx_x: <span class="bu">int</span>, idx_y: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb3-270"><a href="#cb3-270" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">buffer</span>[idx_y <span class="op">*</span> grid_map.num_of_cells_x() <span class="op">+</span> idx_x]</span>
<span id="cb3-271"><a href="#cb3-271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-272"><a href="#cb3-272" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> set_buffer(idx_x: <span class="bu">int</span>, idx_y: <span class="bu">int</span>, value: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb3-273"><a href="#cb3-273" aria-hidden="true" tabindex="-1"></a>        <span class="bu">buffer</span>[idx_y <span class="op">*</span> grid_map.num_of_cells_x() <span class="op">+</span> idx_x] <span class="op">=</span> value</span>
<span id="cb3-274"><a href="#cb3-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-275"><a href="#cb3-275" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> set_coarse_map(idx_x: <span class="bu">int</span>, idx_y: <span class="bu">int</span>, value: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb3-276"><a href="#cb3-276" aria-hidden="true" tabindex="-1"></a>        coarse_map.set_index_value(idx_x, idx_y, value)</span>
<span id="cb3-277"><a href="#cb3-277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-278"><a href="#cb3-278" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sliding window maximum for y-axis</span></span>
<span id="cb3-279"><a href="#cb3-279" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(grid_map.num_of_cells_x()):</span>
<span id="cb3-280"><a href="#cb3-280" aria-hidden="true" tabindex="-1"></a>        in_func_row <span class="op">=</span> <span class="kw">lambda</span> y: grid_map.get_index_value(x, y)</span>
<span id="cb3-281"><a href="#cb3-281" aria-hidden="true" tabindex="-1"></a>        out_func_row <span class="op">=</span> <span class="kw">lambda</span> y, max_value: set_buffer(x, y, max_value)</span>
<span id="cb3-282"><a href="#cb3-282" aria-hidden="true" tabindex="-1"></a>        sliding_window_max(in_func_row, out_func_row, <span class="op">\</span></span>
<span id="cb3-283"><a href="#cb3-283" aria-hidden="true" tabindex="-1"></a>                           grid_map.num_of_cells_y(), win_size)</span>
<span id="cb3-284"><a href="#cb3-284" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-285"><a href="#cb3-285" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sliding window maximum for x-axis</span></span>
<span id="cb3-286"><a href="#cb3-286" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(grid_map.num_of_cells_y()):</span>
<span id="cb3-287"><a href="#cb3-287" aria-hidden="true" tabindex="-1"></a>        in_func_col <span class="op">=</span> <span class="kw">lambda</span> x: get_buffer(x, y)</span>
<span id="cb3-288"><a href="#cb3-288" aria-hidden="true" tabindex="-1"></a>        out_func_col <span class="op">=</span> <span class="kw">lambda</span> x, max_value: set_coarse_map(x, y, max_value)</span>
<span id="cb3-289"><a href="#cb3-289" aria-hidden="true" tabindex="-1"></a>        sliding_window_max(in_func_col, out_func_col, <span class="op">\</span></span>
<span id="cb3-290"><a href="#cb3-290" aria-hidden="true" tabindex="-1"></a>                           grid_map.num_of_cells_x(), win_size)</span>
<span id="cb3-291"><a href="#cb3-291" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-292"><a href="#cb3-292" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> coarse_map</span>
<span id="cb3-293"><a href="#cb3-293" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-294"><a href="#cb3-294" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_coarse_map_fast(grid_map: Grid2D, win_size: <span class="bu">int</span>) <span class="op">-&gt;</span> Grid2D:</span>
<span id="cb3-295"><a href="#cb3-295" aria-hidden="true" tabindex="-1"></a>    num_of_cells_x <span class="op">=</span> grid_map.num_of_cells_x()</span>
<span id="cb3-296"><a href="#cb3-296" aria-hidden="true" tabindex="-1"></a>    num_of_cells_y <span class="op">=</span> grid_map.num_of_cells_y()</span>
<span id="cb3-297"><a href="#cb3-297" aria-hidden="true" tabindex="-1"></a>    num_of_cells <span class="op">=</span> num_of_cells_x <span class="op">*</span> num_of_cells_y</span>
<span id="cb3-298"><a href="#cb3-298" aria-hidden="true" tabindex="-1"></a>    <span class="bu">buffer</span> <span class="op">=</span> [<span class="dv">0</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_of_cells)]</span>
<span id="cb3-299"><a href="#cb3-299" aria-hidden="true" tabindex="-1"></a>    coarse_map <span class="op">=</span> Grid2D(grid_map.resolution(), <span class="op">*</span>grid_map.center_pos(),</span>
<span id="cb3-300"><a href="#cb3-300" aria-hidden="true" tabindex="-1"></a>                        grid_map.num_of_cells_x(), grid_map.num_of_cells_y(),</span>
<span id="cb3-301"><a href="#cb3-301" aria-hidden="true" tabindex="-1"></a>                        grid_map.log_odds_hit(), grid_map.log_odds_miss())</span>
<span id="cb3-302"><a href="#cb3-302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-303"><a href="#cb3-303" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sliding window maximum for y-axis</span></span>
<span id="cb3-304"><a href="#cb3-304" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(num_of_cells_x):</span>
<span id="cb3-305"><a href="#cb3-305" aria-hidden="true" tabindex="-1"></a>        idx_queue, idx_in, idx_out <span class="op">=</span> deque(), <span class="dv">0</span>, <span class="dv">0</span></span>
<span id="cb3-306"><a href="#cb3-306" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-307"><a href="#cb3-307" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> idx_in <span class="op">&lt;</span> win_size:</span>
<span id="cb3-308"><a href="#cb3-308" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> idx_queue <span class="kw">and</span> grid_map.get_index_value(x, idx_in) <span class="op">&gt;=</span> <span class="op">\</span></span>
<span id="cb3-309"><a href="#cb3-309" aria-hidden="true" tabindex="-1"></a>                grid_map.get_index_value(x, idx_queue[<span class="op">-</span><span class="dv">1</span>]):</span>
<span id="cb3-310"><a href="#cb3-310" aria-hidden="true" tabindex="-1"></a>                idx_queue.pop()</span>
<span id="cb3-311"><a href="#cb3-311" aria-hidden="true" tabindex="-1"></a>            idx_queue.append(idx_in)</span>
<span id="cb3-312"><a href="#cb3-312" aria-hidden="true" tabindex="-1"></a>            idx_in <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-313"><a href="#cb3-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-314"><a href="#cb3-314" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> idx_in <span class="op">&lt;</span> num_of_cells_y:</span>
<span id="cb3-315"><a href="#cb3-315" aria-hidden="true" tabindex="-1"></a>            <span class="bu">buffer</span>[idx_out <span class="op">*</span> num_of_cells_x <span class="op">+</span> x] <span class="op">=</span> <span class="op">\</span></span>
<span id="cb3-316"><a href="#cb3-316" aria-hidden="true" tabindex="-1"></a>                grid_map.get_index_value(x, idx_queue[<span class="dv">0</span>])</span>
<span id="cb3-317"><a href="#cb3-317" aria-hidden="true" tabindex="-1"></a>            idx_out <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-318"><a href="#cb3-318" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-319"><a href="#cb3-319" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> idx_queue <span class="kw">and</span> idx_queue[<span class="dv">0</span>] <span class="op">&lt;=</span> idx_in <span class="op">-</span> win_size:</span>
<span id="cb3-320"><a href="#cb3-320" aria-hidden="true" tabindex="-1"></a>                idx_queue.popleft()</span>
<span id="cb3-321"><a href="#cb3-321" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> idx_queue <span class="kw">and</span> grid_map.get_index_value(x, idx_in) <span class="op">&gt;=</span> <span class="op">\</span></span>
<span id="cb3-322"><a href="#cb3-322" aria-hidden="true" tabindex="-1"></a>                grid_map.get_index_value(x, idx_queue[<span class="op">-</span><span class="dv">1</span>]):</span>
<span id="cb3-323"><a href="#cb3-323" aria-hidden="true" tabindex="-1"></a>                idx_queue.pop()</span>
<span id="cb3-324"><a href="#cb3-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-325"><a href="#cb3-325" aria-hidden="true" tabindex="-1"></a>            idx_queue.append(idx_in)</span>
<span id="cb3-326"><a href="#cb3-326" aria-hidden="true" tabindex="-1"></a>            idx_in <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-327"><a href="#cb3-327" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-328"><a href="#cb3-328" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> idx_out <span class="op">&lt;</span> num_of_cells_y:</span>
<span id="cb3-329"><a href="#cb3-329" aria-hidden="true" tabindex="-1"></a>            <span class="bu">buffer</span>[idx_out <span class="op">*</span> num_of_cells_x <span class="op">+</span> x] <span class="op">=</span> <span class="op">\</span></span>
<span id="cb3-330"><a href="#cb3-330" aria-hidden="true" tabindex="-1"></a>                grid_map.get_index_value(x, idx_queue[<span class="dv">0</span>])</span>
<span id="cb3-331"><a href="#cb3-331" aria-hidden="true" tabindex="-1"></a>            idx_out <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-332"><a href="#cb3-332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-333"><a href="#cb3-333" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sliding window maximum for x-axis</span></span>
<span id="cb3-334"><a href="#cb3-334" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(num_of_cells_y):</span>
<span id="cb3-335"><a href="#cb3-335" aria-hidden="true" tabindex="-1"></a>        idx_queue, idx_in, idx_out <span class="op">=</span> deque(), <span class="dv">0</span>, <span class="dv">0</span></span>
<span id="cb3-336"><a href="#cb3-336" aria-hidden="true" tabindex="-1"></a>        idx_offset <span class="op">=</span> y <span class="op">*</span> num_of_cells_x</span>
<span id="cb3-337"><a href="#cb3-337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-338"><a href="#cb3-338" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> idx_in <span class="op">&lt;</span> win_size:</span>
<span id="cb3-339"><a href="#cb3-339" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> idx_queue <span class="kw">and</span> <span class="bu">buffer</span>[idx_offset <span class="op">+</span> idx_in] <span class="op">&gt;=</span> <span class="op">\</span></span>
<span id="cb3-340"><a href="#cb3-340" aria-hidden="true" tabindex="-1"></a>                <span class="bu">buffer</span>[idx_offset <span class="op">+</span> idx_queue[<span class="op">-</span><span class="dv">1</span>]]:</span>
<span id="cb3-341"><a href="#cb3-341" aria-hidden="true" tabindex="-1"></a>                idx_queue.pop()</span>
<span id="cb3-342"><a href="#cb3-342" aria-hidden="true" tabindex="-1"></a>            idx_queue.append(idx_in)</span>
<span id="cb3-343"><a href="#cb3-343" aria-hidden="true" tabindex="-1"></a>            idx_in <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-344"><a href="#cb3-344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-345"><a href="#cb3-345" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> idx_in <span class="op">&lt;</span> num_of_cells_x:</span>
<span id="cb3-346"><a href="#cb3-346" aria-hidden="true" tabindex="-1"></a>            coarse_map.set_index_value(</span>
<span id="cb3-347"><a href="#cb3-347" aria-hidden="true" tabindex="-1"></a>                idx_out, y, <span class="bu">buffer</span>[idx_offset <span class="op">+</span> idx_queue[<span class="dv">0</span>]])</span>
<span id="cb3-348"><a href="#cb3-348" aria-hidden="true" tabindex="-1"></a>            idx_out <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-349"><a href="#cb3-349" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-350"><a href="#cb3-350" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> idx_queue <span class="kw">and</span> idx_queue[<span class="dv">0</span>] <span class="op">&lt;=</span> idx_in <span class="op">-</span> win_size:</span>
<span id="cb3-351"><a href="#cb3-351" aria-hidden="true" tabindex="-1"></a>                idx_queue.popleft()</span>
<span id="cb3-352"><a href="#cb3-352" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> idx_queue <span class="kw">and</span> <span class="bu">buffer</span>[idx_offset <span class="op">+</span> idx_in] <span class="op">&gt;=</span> <span class="op">\</span></span>
<span id="cb3-353"><a href="#cb3-353" aria-hidden="true" tabindex="-1"></a>                <span class="bu">buffer</span>[idx_offset <span class="op">+</span> idx_queue[<span class="op">-</span><span class="dv">1</span>]]:</span>
<span id="cb3-354"><a href="#cb3-354" aria-hidden="true" tabindex="-1"></a>                idx_queue.pop()</span>
<span id="cb3-355"><a href="#cb3-355" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-356"><a href="#cb3-356" aria-hidden="true" tabindex="-1"></a>            idx_queue.append(idx_in)</span>
<span id="cb3-357"><a href="#cb3-357" aria-hidden="true" tabindex="-1"></a>            idx_in <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-358"><a href="#cb3-358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-359"><a href="#cb3-359" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> idx_out <span class="op">&lt;</span> num_of_cells_x:</span>
<span id="cb3-360"><a href="#cb3-360" aria-hidden="true" tabindex="-1"></a>            coarse_map.set_index_value(</span>
<span id="cb3-361"><a href="#cb3-361" aria-hidden="true" tabindex="-1"></a>                idx_out, y, <span class="bu">buffer</span>[idx_offset <span class="op">+</span> idx_queue[<span class="dv">0</span>]])</span>
<span id="cb3-362"><a href="#cb3-362" aria-hidden="true" tabindex="-1"></a>            idx_out <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-363"><a href="#cb3-363" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-364"><a href="#cb3-364" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> coarse_map</span>
<span id="cb3-365"><a href="#cb3-365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-366"><a href="#cb3-366" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_coarse_map(grid_map: Grid2D, win_size: <span class="bu">int</span>) <span class="op">-&gt;</span> Grid2D:</span>
<span id="cb3-367"><a href="#cb3-367" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> compute_coarse_map_fast(grid_map, win_size)</span></code></pre></div>
<h2 id="分枝限定法によるスキャンマッチングの実装">分枝限定法によるスキャンマッチングの実装</h2>
<p>続いて、分枝限定法によるスキャンマッチングの実装(<code>ScanMatcherBranchBound</code>クラス)を示します。 <code>ScanMatcherBranchBound</code>クラスのソースコードは<a href="https://github.com/sterngerlach/scan_matcher_2d_python/blob/master/scan_matcher_branch_bound.py">こちら</a>を参照してください。 アルゴリズムの説明は大変でしたが、実装自体は100行程度で済みます。</p>
<ul>
<li>コンストラクタでは、アルゴリズムの各種パラメータを初期化します。 探索領域のサイズ<span class="math inline">\(2W_x, 2W_y, 2W_\theta\)</span>を<code>window_size_x</code>、<code>window_size_y</code>、<code>window_size_theta</code>の3つのメンバ、<span class="math inline">\(\theta\)</span>方向のステップサイズの最小値<span class="math inline">\(\delta_{\theta, \mathrm{min}}\)</span>を<code>min_step_theta</code>メンバ、ノードの最大の高さ<span class="math inline">\(h_0\)</span>を<code>max_node_height</code>メンバ、<span class="math inline">\(2^{h_0}\)</span>を<code>max_stride</code>メンバに格納します。</li>
<li><code>compute_step()</code>メソッドは、占有格子地図の解像度<span class="math inline">\(r\)</span>と、スキャンデータ<span class="math inline">\(\mathcal{S}\)</span>を基に、<span class="math inline">\(x\)</span>、<span class="math inline">\(y\)</span>、<span class="math inline">\(\theta\)</span>方向のステップサイズ(<span class="math inline">\(r\)</span>および<span class="math inline">\(\delta_\theta\)</span>)を計算します。 <span class="math display">\[
\delta_\theta = \max \left( \delta_{\theta, \mathrm{min}}, \arccos \left( 1 - \frac{r^2}{2 d_\mathrm{max}^2} \right) \right)
\]</span> <span class="math inline">\(d_\mathrm{max}\)</span>は、LiDARセンサの中心から、スキャン点までの距離の最大値です。 スキャンデータ<span class="math inline">\(\mathcal{S} = \left\{ (r_1, \theta_1), \ldots, (r_N, \theta_N) \right\}\)</span>について、<span class="math inline">\(d_\mathrm{max} = \max_i r_i\)</span>となります。</li>
<li><code>compute_window()</code>メソッドは、探索領域のサイズ<span class="math inline">\(W_x, W_y, W_\theta\)</span>とステップサイズ<span class="math inline">\(r, \delta_\theta\)</span>を基に、各軸方向の解の候補数<span class="math inline">\(w_x, w_y, w_\theta\)</span>を計算します。 <span class="math display">\[
w_x = \left\lceil \frac{W_x}{r} \right\rceil, \
w_y = \left\lceil \frac{W_y}{r} \right\rceil, \
w_\theta = \left\lceil \frac{W_\theta}{\delta_\theta} \right\rceil
\]</span></li>
<li><code>compute_score()</code>メソッドは、指定されたインデックスの格子がもつ占有確率を足し合わせて、スコアを計算します(詳細は後ほど説明します)。</li>
</ul>
<p><code>match_scan()</code>メソッドは、分枝限定法によるスキャンマッチングの本体です。 <a href="./scan-matching-branch-and-bound.html">以前のページ</a>の末尾に示したアルゴリズムと照らし合わせて、ソースコードを詳しくみてみましょう。</p>
<ul>
<li><p>引数<code>initial_pose</code>、<code>grid_map</code>、<code>scan</code>から、探索領域の中心に対応する姿勢<span class="math inline">\(\mathbf{\xi}_0 = \left[ \xi_{0, x}, \xi_{0, y}, \xi_{0, \theta} \right]^\top\)</span>、占有格子地図<span class="math inline">\(\mathcal{M}\)</span>(解像度<span class="math inline">\(r\)</span>)、スキャンデータ<span class="math inline">\(\mathcal{S}\)</span>を受け取ります。 <a href="./scan-matching-branch-and-bound.html">以前のページ</a>では、スキャンデータは極座標形式(距離<span class="math inline">\(r_i\)</span>と方向<span class="math inline">\(\theta_i\)</span>)で表現していましたが、この実装では直交座標(<span class="math inline">\(x, y\)</span>)を用いています。 あるスキャンが極座標で<span class="math inline">\(\mathbf{z}_i = (r_i, \theta_i)\)</span>のように表されるとき、<span class="math inline">\((r_i \cos \theta_i, r_i \sin \theta_i)\)</span>とすれば直交座標に変換できます。 また、直交座標で<span class="math inline">\(\mathbf{z}_i = (x_i, y_i)\)</span>のように表されるとき、<span class="math inline">\((\sqrt{x_i^2 + y_i^2}, \arctan \cfrac{y_i}{x_i})\)</span>とすれば極座標に変換できます。</p></li>
<li><p>最初に、<code>compute_step()</code>メソッドと<code>compute_window()</code>メソッドを使って、ステップサイズ<span class="math inline">\(r, \delta_\theta\)</span>と探索領域のサイズ<span class="math inline">\(w_x, w_y, w_\theta\)</span>を計算します。 変数<code>step_x</code>、<code>step_y</code>、<code>step_theta</code>は、<span class="math inline">\(r\)</span>, <span class="math inline">\(r\)</span>, <span class="math inline">\(\delta_\theta\)</span>に対応します。 また変数<code>win_x</code>、<code>win_y</code>、<code>win_theta</code>は、<span class="math inline">\(w_x\)</span>、<span class="math inline">\(w_y\)</span>、<span class="math inline">\(w_\theta\)</span>に対応します。 スコアの最大値<span class="math inline">\(s^*\)</span>と最適解<span class="math inline">\((j_x^*, j_y^*, j_\theta^*) \in \overline{\mathcal{W}}\)</span>は、変数<code>best_score</code>、<code>best_x</code>、<code>best_y</code>、<code>best_theta</code>にそれぞれ保持します。 <a href="./scan-matching-branch-and-bound.html">以前のページ</a>では、次のように探索領域<span class="math inline">\(\overline{\mathcal{W}}\)</span>を定義していました。 <span class="math display">\[
\overline{\mathcal{W}} = \left\{ 0, \ldots, 2w_x \right\}
\times \left\{ 0, \ldots, 2w_y \right\}
\times \left\{ 0, \ldots, 2w_\theta \right\}
\]</span> <span class="math display">\[
\mathcal{W} = \left\{ \mathcal{\xi}_0
+ \left[ r \left( -w_x + j_x \right), r \left( -w_y + j_y \right),
\delta_\theta \left( -w_\theta + j_\theta \right) \right]^\top \mid
\left( j_x, j_y, j_\theta \right) \in \overline{\mathcal{W}} \right\}
\]</span> このメソッド内では、以下の定義を採用しています(上記の<span class="math inline">\(j_x, j_y, j_\theta\)</span>を、<span class="math inline">\(j_x - w_x, j_y - w_y, j_\theta - w_\theta\)</span>に置き換えただけです)。 <span class="math display">\[
\overline{\mathcal{W}} = \left\{ -w_x, \ldots, w_x - 1\right\}
\times \left\{ -w_y, \ldots, w_y - 1\right\}
\times \left\{ -w_\theta, \ldots, w_\theta - 1\right\}
\]</span> <span class="math display">\[
\mathcal{W} = \left\{ \mathcal{\xi}_0
+ \left[ r j_x, r j_y, \delta_\theta j_\theta \right]^\top \mid
\left( j_x, j_y, j_\theta \right) \in \overline{\mathcal{W}} \right\}
\]</span></p></li>
<li><p>続いて、<code>compute_coarse_map()</code>メソッドを使って、与えられた地図<span class="math inline">\(\mathcal{M}\)</span>から、<span class="math inline">\(h_0\)</span>個の地図<span class="math inline">\(\mathcal{M}_\mathrm{precomp}^1, \ldots, \mathcal{M}_\mathrm{precomp}^{h_0}\)</span>を計算します。 元々の地図<span class="math inline">\(\mathcal{M}\)</span>と、計算した地図<span class="math inline">\(\mathcal{M}_\mathrm{precomp}^h\)</span>をまとめて、変数<code>grid_maps</code>に格納します。 <span class="math display">\[
\mathcal{M}_\mathrm{precomp}^h(i, j)
= \max_{\substack{i \le i&#39; &lt; i + 2^h \\ j \le j&#39; &lt; j + 2^h}} \mathcal{M}(i&#39;, j&#39;)
\]</span></p></li>
<li><p>その後、優先度付きキュー<span class="math inline">\(\mathcal{C}\)</span>を作成します(ここでは優先度付きキューを用いましたが、単なるスタックで良いと思います)。 これは変数<code>node_queue</code>に対応します。 優先度付きキュー<span class="math inline">\(\mathcal{C}\)</span>を、高さ<span class="math inline">\(h_0\)</span>の一連のノード<span class="math inline">\(\mathcal{C}_0\)</span>で初期化します(探索領域の定義が少し異なるので、それに応じて<span class="math inline">\(\overline{\mathcal{W}}_0\)</span>と<span class="math inline">\(\mathcal{C}_0\)</span>の定義も変えています)。 ソースコードは変数<code>x</code>、<code>y</code>、<code>t</code>の3重ループになっていますが、<span class="math inline">\(\overline{\mathcal{W}}_{0, x}\)</span>、<span class="math inline">\(\overline{\mathcal{W}}_{0, y}\)</span>、<span class="math inline">\(\overline{\mathcal{W}}_{0, \theta}\)</span>の各要素を順に辿っているわけです。 <span class="math display">\[
\begin{eqnarray}
  \overline{\mathcal{W}}_{0, x} &amp;=&amp; \left\{ -w_x + 2^{h_0} j_x \mid
  j_x \in \mathbb{Z}, 0 \le 2^{h_0} j_x &lt; 2 w_x \right\} \\
  \overline{\mathcal{W}}_{0, y} &amp;=&amp; \left\{ -w_y + 2^{h_0} j_y \mid
  j_y \in \mathbb{Z}, 0 \le 2^{h_0} j_y &lt; 2 w_y \right\} \\
  \overline{\mathcal{W}}_{0, \theta} &amp;=&amp; \left\{ j_\theta \mid
  j_\theta \in \mathbb{Z}, -w_\theta \le j_\theta &lt; w_\theta \right\} \\
  \mathcal{C}_0 &amp;=&amp; \overline{\mathcal{W}}_{0, x}
  \times \overline{\mathcal{W}}_{0, y}
  \times \overline{\mathcal{W}}_{0, \theta}
  \times \left\{ h_0 \right\}
\end{eqnarray}
\]</span> 各ノード<span class="math inline">\(\mathbf{c} = \left( -w_x + 2^{h_0} j_x, -w_y + 2^{h_0} j_y, j_\theta, h_0 \right) \in \mathcal{C}_0\)</span>について、<code>append_node()</code>関数を呼び出します。 引数<code>x</code>、<code>y</code>、<code>t</code>は、<span class="math inline">\(-w_x + 2^{h_0} j_x\)</span>、<span class="math inline">\(-w_y + 2^{h_0} j_y\)</span>、<span class="math inline">\(j_\theta\)</span>に対応します。 また引数<code>height</code>は<span class="math inline">\(h_0\)</span>、引数<code>indices</code>は以下で定義するインデックス<span class="math inline">\(\{ (I_{i, x}^0, I_{i, y}^0) \}\)</span>に対応します。 <code>append_node()</code>関数内では、スコアの上界<span class="math inline">\(\overline{s}(\mathbf{c})\)</span>を次のような手順で計算し、変数<code>score</code>に格納します。 最初に、解の候補<span class="math inline">\((0, 0, j_\theta)\)</span>に対応する姿勢<span class="math inline">\(\mathbf{\xi}(0, 0, j_\theta)\)</span>を計算し、変数<code>pose</code>に格納します。 <span class="math display">\[
\mathbf{\xi}(0, 0, j_\theta)
= \mathbf{\xi}_0 + \left[ 0, 0, \delta_\theta j_\theta \right]^\top
= \left[ \xi_{0, x}, \xi_{0, y},
\xi_{0, \theta} + \delta_\theta j_\theta \right]^\top
\]</span> この姿勢<span class="math inline">\(\mathbf{\xi}(0, 0, j_\theta)\)</span>を基に、スキャン点<span class="math inline">\(\mathbf{z}_i = (r_i, \theta_i)\)</span>に対応する地図上の格子のインデックス<span class="math inline">\((I_{i, x}^0, I_{i, y}^0)\)</span>を計算し、変数<code>indices</code>に格納します。 <span class="math display">\[
\begin{eqnarray}
  I_{i, x}^0 &amp;=&amp; \left\lfloor \frac{\xi_{0, x} + r_i \cos \left(
  \xi_{0, \theta} + \delta_\theta j_\theta
  + \theta_i \right)}{r} \right\rfloor \\
  I_{i, y}^0 &amp;=&amp; \left\lfloor \frac{\xi_{0, y} + r_i \sin \left(
  \xi_{0, \theta} + \delta_\theta j_\theta
  + \theta_i \right)}{r} \right\rfloor
\end{eqnarray}
\]</span> その後<code>compute_score()</code>メソッドを用いて、スコアの上界<span class="math inline">\(\overline{s}(\mathbf{c})\)</span>を計算します。 <code>compute_score()</code>メソッドの引数<code>grid_map</code>は<span class="math inline">\(\mathcal{M}_\mathrm{precomp}^{h_0}\)</span>、<code>indices</code>はインデックス<span class="math inline">\(\{ (I_{i, x}^0, I_{i, y}^0) \}\)</span>、また<code>offset</code>は<span class="math inline">\((-w_x + 2^{h_0} j_x, -w_y + 2^{h_0} j_y)\)</span>にそれぞれ対応しています。 <span class="math display">\[
\overline{s}(\mathbf{c}) = \sum_{i = 1}^N
\mathcal{M}_\mathrm{precomp}^{h_0}(I_{i, x}^0 - w_x + 2^{h_0} j_x,
I_{i, y}^0 - w_y + 2^{h_0} j_y)
\]</span> スコアの上界<span class="math inline">\(\overline{s}(\mathbf{c})\)</span>が最も高いノード<span class="math inline">\(\mathbf{c} \in \mathcal{C}_0\)</span>が先頭に来るように、<span class="math inline">\(\mathcal{C}_0\)</span>に含まれる全てのノードを優先度付きキュー<span class="math inline">\(\mathcal{C}\)</span>に追加していきます。 優先度付きキューには、ノード<span class="math inline">\(\mathbf{c}\)</span>の4つのパラメータ<span class="math inline">\((-w_x + 2^{h_0} j_x, -w_y + 2^{h_0} j_y, j_\theta, h_0)\)</span>(変数<code>x</code>、<code>y</code>、<code>theta</code>、<code>height</code>)のほかに、スコアの上界<span class="math inline">\(\overline{s}(\mathbf{c})\)</span>(変数<code>score</code>)、そしてインデックス<span class="math inline">\(\{ (I_{i, x}^0, I_{i, y}^0) \}\)</span>(変数<code>indices</code>)も追加しておきます。</p></li>
<li><p>優先度付きキュー<span class="math inline">\(\mathcal{C}\)</span>(変数<code>node_queue</code>)が空になるまで、以下の処理を繰り返します。</p>
<ul>
<li><p><span class="math inline">\(\mathcal{C}\)</span>の先頭から、ノード<span class="math inline">\(\mathbf{c} = (c_x, c_y, c_\theta, h) \in \overline{\mathcal{W}}\)</span>とスコアの上界<span class="math inline">\(\overline{s}(\mathbf{c})\)</span>、そしてインデックス<span class="math inline">\(\{ (I_{i, x}^0, I_{i, y}^0) \}\)</span>を取得します。 <span class="math inline">\((I_{i, x}^0, I_{i, y}^0)\)</span>は、姿勢<span class="math inline">\(\mathbf{\xi}(0, 0, c_\theta)\)</span>のもとで計算した、スキャン点<span class="math inline">\(\mathbf{z}_i = (r_i, \theta_i)\)</span>に対応する格子のインデックスです(上記の説明を確認してください)。 <span class="math inline">\(c_x, c_y, c_\theta, h\)</span>は変数<code>x</code>、<code>y</code>、<code>t</code>、<code>height</code>、上界<span class="math inline">\(\overline{s}(\mathbf{c})\)</span>は変数<code>score</code>、またインデックス<span class="math inline">\(\{ (I_{i, x}^0, I_{i, y}^0) \}\)</span>は変数<code>indices</code>に格納されます。</p></li>
<li><p>スコアの上界<span class="math inline">\(\overline{s}(\mathbf{c})\)</span>が、現在の最大スコア<span class="math inline">\(s^*\)</span>(変数<code>best_score</code>)以下であれば、現在のノード<span class="math inline">\(\mathbf{c}\)</span>と、その子ノードの探索は不要です(<strong>枝刈り</strong>)。</p></li>
<li><p>現在のノード<span class="math inline">\(\mathbf{c}\)</span>が葉ノードである場合(高さ<span class="math inline">\(h = 0\)</span>)は、現在の最大スコア<span class="math inline">\(s^*\)</span>(変数<code>best_score</code>)を<span class="math inline">\(\overline{s}(\mathbf{c})\)</span>、また最適解<span class="math inline">\((j_x^*, j_y^*, j_\theta^*)\)</span>(変数<code>best_x</code>、<code>best_y</code>、<code>best_theta</code>)を<span class="math inline">\((c_x, c_y, c_\theta)\)</span>で更新します。</p></li>
<li><p>現在のノード<span class="math inline">\(\mathbf{c}\)</span>が葉ノードでなければ、4つの子ノード<span class="math inline">\(\mathbf{c}_1, \mathbf{c}_2, \mathbf{c}_3, \mathbf{c}_4\)</span>に分割します。 <span class="math display">\[
\begin{eqnarray}
  \mathbf{c}_1 &amp;=&amp; (c_x, c_y, c_\theta, h - 1) \\
  \mathbf{c}_2 &amp;=&amp; (c_x + 2^{h - 1}, c_y, c_\theta, h - 1) \\
  \mathbf{c}_3 &amp;=&amp; (c_x, c_y + 2^{h - 1}, c_\theta, h - 1) \\
  \mathbf{c}_4 &amp;=&amp; (c_x + 2^{h - 1}, c_y + 2^{h - 1}, c_\theta, h - 1)
\end{eqnarray}
\]</span> 変数<code>new_x</code>、<code>new_y</code>、<code>new_height</code>、<code>s</code>は、<span class="math inline">\(c_x, c_y, h - 1, 2^{h - 1}\)</span>にそれぞれ対応します。 4つの子ノードに対して<code>append_node()</code>関数が順に呼び出されます。 <code>append_node()</code>関数内では、スコアの上界<span class="math inline">\(\overline{s}(\mathbf{c}_1), \overline{s}(\mathbf{c}_2), \overline{s}(\mathbf{c}_3), \overline{s}(\mathbf{c}_4)\)</span>を計算します。 <span class="math display">\[
\begin{eqnarray}
  \overline{s}(\mathbf{c}_1)
  &amp;=&amp; \sum_{i = 1}^N \mathcal{M}_\mathrm{precomp}^{h - 1}(
  I_{i, x}^0 + c_x, I_{i, y}^0 + c_y) \\
  \overline{s}(\mathbf{c}_2)
  &amp;=&amp; \sum_{i = 1}^N \mathcal{M}_\mathrm{precomp}^{h - 1}(
  I_{i, x}^0 + c_x + 2^{h - 1}, I_{i, y}^0 + c_y) \\
  \overline{s}(\mathbf{c}_3)
  &amp;=&amp; \sum_{i = 1}^N \mathcal{M}_\mathrm{precomp}^{h - 1}(
  I_{i, x}^0 + c_x, I_{i, y}^0 + c_y + 2^{h - 1}) \\
  \overline{s}(\mathbf{c}_4)
  &amp;=&amp; \sum_{i = 1}^N \mathcal{M}_\mathrm{precomp}^{h - 1}(
  I_{i, x}^0 + c_x + 2^{h - 1}, I_{i, y}^0 + c_y + 2^{h - 1}) \\
  I_{i, x}^0 &amp;=&amp; \left\lfloor \frac{\xi_{0, x} + r_i \cos \left(
  \xi_{0, \theta} + \delta_\theta c_\theta
  + \theta_i \right)}{r} \right\rfloor \\
  I_{i, y}^0 &amp;=&amp; \left\lfloor \frac{\xi_{0, y} + r_i \sin \left(
  \xi_{0, \theta} + \delta_\theta c_\theta
  + \theta_i \right)}{r} \right\rfloor
\end{eqnarray}
\]</span> 4つの子ノードは、親ノード<span class="math inline">\(\mathbf{c}\)</span>と同様の回転<span class="math inline">\(c_\theta\)</span>を表しています。 従って、スコアの上界の計算時にインデックス<span class="math inline">\(\{ (I_{i, x}^0, I_{i, y}^0) \}\)</span>を再利用できます。 LiDAR座標系から地図座標系への座標変換と、地図座標から格子のインデックスへの変換の2つを省略できます。 上界の最も大きな子ノードが先頭に来るように、4つの子ノードを優先度付きキューに追加していきます(ノードの4つのパラメータに加えて、上界とインデックスも一緒に追加)。</p></li>
</ul></li>
<li><p>上記の手続きによって最適解<span class="math inline">\((j_x^*, j_y^*, j_\theta^*) \in \overline{\mathcal{W}}\)</span>が得られたので、最適な姿勢<span class="math inline">\(\mathbf{\xi}^* \in \mathcal{W}\)</span>を計算します(変数<code>best_pose</code>)。 <span class="math display">\[
\mathbf{\xi}^* = \left[ \xi_{0, x} + r j_x^*, \xi_{0, y} + r j_y^*,
\xi_{0, \theta} + \delta_\theta j_\theta^* \right]^\top \in \mathcal{W}
\]</span></p></li>
<li><p>スコアの最大値<span class="math inline">\(s^*\)</span>、最適解<span class="math inline">\((j_x^*, j_y^*, j_\theta^*) \in \overline{\mathcal{W}}\)</span>、最適な姿勢<span class="math inline">\(\mathbf{\xi}^* \in \mathcal{W}\)</span>などをまとめて返します。</p></li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># coding: utf-8</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co"># scan_matcher_branch_bound.py</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Any, List, Tuple</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> grid_2d <span class="im">import</span> Grid2D, compute_coarse_map</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> point_2d <span class="im">import</span> Point2D</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pose_2d <span class="im">import</span> Pose2D, project_point_2d, wrap_angle</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ScanMatcherBranchBound(<span class="bu">object</span>):</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;`ScanMatcherBranchBound` class implements branch-and-bound scan matching,</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="co">    which aligns a LiDAR scan and a 2D occupancy grid map. </span><span class="ch">\n</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="co">    For more details, please refer to the following paper: </span><span class="ch">\n</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="co">    Wolfgang Hess, Damon Kohler, Holger Rapp, and Daniel Andor.</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;Real-time Loop Closure in 2D LiDAR SLAM,&quot; in Proceedings of the IEEE</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="co">    International Conference on Robotics and Automation (ICRA), 2016.</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Result(<span class="bu">object</span>):</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, win: Tuple[<span class="bu">int</span>, <span class="bu">int</span>, <span class="bu">int</span>],</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>                     step: Tuple[<span class="bu">float</span>, <span class="bu">float</span>, <span class="bu">float</span>],</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>                     best: Tuple[<span class="bu">int</span>, <span class="bu">int</span>, <span class="bu">int</span>], best_score: <span class="bu">float</span>,</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>                     initial_pose: Pose2D, best_pose: Pose2D,</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>                     num_solutions: <span class="bu">int</span>, num_processed: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.win_x, <span class="va">self</span>.win_y, <span class="va">self</span>.win_theta <span class="op">=</span> win</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.step_x, <span class="va">self</span>.step_y, <span class="va">self</span>.step_theta <span class="op">=</span> step</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.best_x, <span class="va">self</span>.best_y, <span class="va">self</span>.best_theta <span class="op">=</span> best</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.best_score <span class="op">=</span> best_score</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.initial_pose <span class="op">=</span> initial_pose</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.best_pose <span class="op">=</span> best_pose</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.num_solutions <span class="op">=</span> num_solutions</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.num_processed <span class="op">=</span> num_processed</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> dump(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>            msg <span class="op">=</span> <span class="st">&quot;Statistics for branch-and-bound scan matcher</span><span class="ch">\n</span><span class="st">&quot;</span> \</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>                  <span class="st">&quot;Window size: (</span><span class="sc">{}</span><span class="st">, </span><span class="sc">{}</span><span class="st">, </span><span class="sc">{}</span><span class="st">)</span><span class="ch">\n</span><span class="st">&quot;</span> \</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>                  <span class="st">&quot;Step size: (</span><span class="sc">{:.6f}</span><span class="st"> m, </span><span class="sc">{:.6f}</span><span class="st"> m, </span><span class="sc">{:.6f}</span><span class="st"> rad)</span><span class="ch">\n</span><span class="st">&quot;</span> \</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>                  <span class="st">&quot;Best solution: (</span><span class="sc">{}</span><span class="st">, </span><span class="sc">{}</span><span class="st">, </span><span class="sc">{}</span><span class="st">)</span><span class="ch">\n</span><span class="st">&quot;</span> \</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>                  <span class="st">&quot;Best score: </span><span class="sc">{}</span><span class="ch">\n</span><span class="st">&quot;</span> \</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>                  <span class="st">&quot;Initial pose: (</span><span class="sc">{:.6f}</span><span class="st"> m, </span><span class="sc">{:.6f}</span><span class="st"> m, </span><span class="sc">{:.6f}</span><span class="st"> rad)</span><span class="ch">\n</span><span class="st">&quot;</span> \</span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>                  <span class="st">&quot;Final pose: (</span><span class="sc">{:.6f}</span><span class="st"> m, </span><span class="sc">{:.6f}</span><span class="st"> m, </span><span class="sc">{:.6f}</span><span class="st"> rad)</span><span class="ch">\n</span><span class="st">&quot;</span> \</span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>                  <span class="st">&quot;# of possible solutions: </span><span class="sc">{}</span><span class="ch">\n</span><span class="st">&quot;</span> \</span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>                  <span class="st">&quot;# of solutions processed: </span><span class="sc">{}</span><span class="ch">\n</span><span class="st">&quot;</span></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(msg.<span class="bu">format</span>(<span class="va">self</span>.win_x <span class="op">*</span> <span class="dv">2</span>, <span class="va">self</span>.win_y <span class="op">*</span> <span class="dv">2</span>, <span class="va">self</span>.win_theta <span class="op">*</span> <span class="dv">2</span>,</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>                             <span class="va">self</span>.step_x, <span class="va">self</span>.step_y, <span class="va">self</span>.step_theta,</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>                             <span class="va">self</span>.best_x, <span class="va">self</span>.best_y, <span class="va">self</span>.best_theta,</span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>                             <span class="va">self</span>.best_score,</span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>                             <span class="va">self</span>.initial_pose.x, <span class="va">self</span>.initial_pose.y,</span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>                             <span class="va">self</span>.initial_pose.theta,</span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>                             <span class="va">self</span>.best_pose.x, <span class="va">self</span>.best_pose.y,</span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>                             <span class="va">self</span>.best_pose.theta,</span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>                             <span class="va">self</span>.num_solutions, <span class="va">self</span>.num_processed))</span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, window_size_x: <span class="bu">float</span>, window_size_y: <span class="bu">float</span>,</span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>                 window_size_theta: <span class="bu">float</span>, min_step_theta: <span class="bu">float</span>,</span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a>                 max_node_height: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.window_size_x <span class="op">=</span> window_size_x</span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.window_size_y <span class="op">=</span> window_size_y</span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.window_size_theta <span class="op">=</span> window_size_theta</span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.min_step_theta <span class="op">=</span> min_step_theta</span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.max_node_height <span class="op">=</span> max_node_height</span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.max_stride <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="va">self</span>.max_node_height</span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> compute_step(<span class="va">self</span>, grid_map: Grid2D, scan: List[Point2D]):</span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a>        ranges <span class="op">=</span> [(p.x <span class="op">**</span> <span class="dv">2</span> <span class="op">+</span> p.y <span class="op">**</span> <span class="dv">2</span>) <span class="cf">for</span> p <span class="kw">in</span> scan]</span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a>        theta <span class="op">=</span> grid_map.resolution() <span class="op">/</span> <span class="bu">max</span>(ranges)</span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a>        step_x <span class="op">=</span> grid_map.resolution()</span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a>        step_y <span class="op">=</span> grid_map.resolution()</span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a>        step_theta <span class="op">=</span> math.acos(<span class="fl">1.0</span> <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> (theta <span class="op">**</span> <span class="dv">2</span>))</span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true" tabindex="-1"></a>        step_theta <span class="op">=</span> <span class="bu">max</span>(step_theta, <span class="va">self</span>.min_step_theta)</span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-76"><a href="#cb4-76" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> step_x, step_y, step_theta</span>
<span id="cb4-77"><a href="#cb4-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-78"><a href="#cb4-78" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> compute_window(<span class="va">self</span>, step_x: <span class="bu">float</span>, step_y: <span class="bu">float</span>, step_theta: <span class="bu">float</span>):</span>
<span id="cb4-79"><a href="#cb4-79" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">int</span>(math.ceil(<span class="fl">0.5</span> <span class="op">*</span> <span class="va">self</span>.window_size_x <span class="op">/</span> step_x)), <span class="op">\</span></span>
<span id="cb4-80"><a href="#cb4-80" aria-hidden="true" tabindex="-1"></a>               <span class="bu">int</span>(math.ceil(<span class="fl">0.5</span> <span class="op">*</span> <span class="va">self</span>.window_size_y <span class="op">/</span> step_y)), <span class="op">\</span></span>
<span id="cb4-81"><a href="#cb4-81" aria-hidden="true" tabindex="-1"></a>               <span class="bu">int</span>(math.ceil(<span class="fl">0.5</span> <span class="op">*</span> <span class="va">self</span>.window_size_theta <span class="op">/</span> step_theta))</span>
<span id="cb4-82"><a href="#cb4-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-83"><a href="#cb4-83" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> compute_score(<span class="va">self</span>, grid_map: Grid2D, indices: List[Tuple[<span class="bu">int</span>, <span class="bu">int</span>]],</span>
<span id="cb4-84"><a href="#cb4-84" aria-hidden="true" tabindex="-1"></a>                      offset: Tuple[<span class="bu">int</span>, <span class="bu">int</span>]) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb4-85"><a href="#cb4-85" aria-hidden="true" tabindex="-1"></a>        score <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-86"><a href="#cb4-86" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> idx_base <span class="kw">in</span> indices:</span>
<span id="cb4-87"><a href="#cb4-87" aria-hidden="true" tabindex="-1"></a>            idx <span class="op">=</span> (idx_base[<span class="dv">0</span>] <span class="op">+</span> offset[<span class="dv">0</span>], idx_base[<span class="dv">1</span>] <span class="op">+</span> offset[<span class="dv">1</span>])</span>
<span id="cb4-88"><a href="#cb4-88" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> grid_map.is_index_inside(<span class="op">*</span>idx):</span>
<span id="cb4-89"><a href="#cb4-89" aria-hidden="true" tabindex="-1"></a>                score <span class="op">+=</span> grid_map.get_index_value(<span class="op">*</span>idx)</span>
<span id="cb4-90"><a href="#cb4-90" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> score</span>
<span id="cb4-91"><a href="#cb4-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-92"><a href="#cb4-92" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> match_scan(<span class="va">self</span>, initial_pose: Pose2D, grid_map: Grid2D,</span>
<span id="cb4-93"><a href="#cb4-93" aria-hidden="true" tabindex="-1"></a>                   scan: List[Point2D]) <span class="op">-&gt;</span> Tuple[Pose2D, Any]:</span>
<span id="cb4-94"><a href="#cb4-94" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Determine the search step and window size</span></span>
<span id="cb4-95"><a href="#cb4-95" aria-hidden="true" tabindex="-1"></a>        step <span class="op">=</span> <span class="va">self</span>.compute_step(grid_map, scan)</span>
<span id="cb4-96"><a href="#cb4-96" aria-hidden="true" tabindex="-1"></a>        win <span class="op">=</span> <span class="va">self</span>.compute_window(<span class="op">*</span>step)</span>
<span id="cb4-97"><a href="#cb4-97" aria-hidden="true" tabindex="-1"></a>        step_x, step_y, step_theta <span class="op">=</span> step</span>
<span id="cb4-98"><a href="#cb4-98" aria-hidden="true" tabindex="-1"></a>        win_x, win_y, win_theta <span class="op">=</span> win</span>
<span id="cb4-99"><a href="#cb4-99" aria-hidden="true" tabindex="-1"></a>        best_x, best_y, best_theta, best_score <span class="op">=</span> <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span></span>
<span id="cb4-100"><a href="#cb4-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-101"><a href="#cb4-101" aria-hidden="true" tabindex="-1"></a>        num_solutions <span class="op">=</span> (<span class="dv">2</span> <span class="op">*</span> win_x) <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> win_y) <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> win_theta)</span>
<span id="cb4-102"><a href="#cb4-102" aria-hidden="true" tabindex="-1"></a>        num_processed <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-103"><a href="#cb4-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-104"><a href="#cb4-104" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Compute coarse grid maps, which are analogous to image pyramids</span></span>
<span id="cb4-105"><a href="#cb4-105" aria-hidden="true" tabindex="-1"></a>        grid_maps <span class="op">=</span> [grid_map]</span>
<span id="cb4-106"><a href="#cb4-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-107"><a href="#cb4-107" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.max_node_height):</span>
<span id="cb4-108"><a href="#cb4-108" aria-hidden="true" tabindex="-1"></a>            grid_maps.append(compute_coarse_map(grid_map, <span class="dv">2</span> <span class="op">&lt;&lt;</span> i))</span>
<span id="cb4-109"><a href="#cb4-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-110"><a href="#cb4-110" aria-hidden="true" tabindex="-1"></a>        <span class="co"># `node_queue` is a priority queue of nodes, where each node represents</span></span>
<span id="cb4-111"><a href="#cb4-111" aria-hidden="true" tabindex="-1"></a>        <span class="co"># a subregion in the 3D search window along x, y, and theta axes</span></span>
<span id="cb4-112"><a href="#cb4-112" aria-hidden="true" tabindex="-1"></a>        node_queue <span class="op">=</span> []</span>
<span id="cb4-113"><a href="#cb4-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-114"><a href="#cb4-114" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> append_node(x: <span class="bu">int</span>, y: <span class="bu">int</span>, theta: <span class="bu">int</span>,</span>
<span id="cb4-115"><a href="#cb4-115" aria-hidden="true" tabindex="-1"></a>                        height: <span class="bu">int</span>, indices: List[Tuple[<span class="bu">int</span>, <span class="bu">int</span>]]):</span>
<span id="cb4-116"><a href="#cb4-116" aria-hidden="true" tabindex="-1"></a>            score <span class="op">=</span> <span class="va">self</span>.compute_score(grid_maps[height], indices, (x, y))</span>
<span id="cb4-117"><a href="#cb4-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-118"><a href="#cb4-118" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> score <span class="op">&gt;</span> best_score:</span>
<span id="cb4-119"><a href="#cb4-119" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Store the negative score as a key, since `heapq.heappop()`</span></span>
<span id="cb4-120"><a href="#cb4-120" aria-hidden="true" tabindex="-1"></a>                <span class="co"># returns a node with the smallest key</span></span>
<span id="cb4-121"><a href="#cb4-121" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(node_queue,</span>
<span id="cb4-122"><a href="#cb4-122" aria-hidden="true" tabindex="-1"></a>                    (<span class="op">-</span>score, (x, y, theta, height, indices, score)))</span>
<span id="cb4-123"><a href="#cb4-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-124"><a href="#cb4-124" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Initialize a priority queue</span></span>
<span id="cb4-125"><a href="#cb4-125" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span>win_theta, win_theta):</span>
<span id="cb4-126"><a href="#cb4-126" aria-hidden="true" tabindex="-1"></a>            pose <span class="op">=</span> Pose2D(initial_pose.x, initial_pose.y,</span>
<span id="cb4-127"><a href="#cb4-127" aria-hidden="true" tabindex="-1"></a>                          initial_pose.theta <span class="op">+</span> t <span class="op">*</span> step_theta)</span>
<span id="cb4-128"><a href="#cb4-128" aria-hidden="true" tabindex="-1"></a>            points <span class="op">=</span> [project_point_2d(pose, p) <span class="cf">for</span> p <span class="kw">in</span> scan]</span>
<span id="cb4-129"><a href="#cb4-129" aria-hidden="true" tabindex="-1"></a>            indices <span class="op">=</span> [grid_map.point_to_index(p) <span class="cf">for</span> p <span class="kw">in</span> points]</span>
<span id="cb4-130"><a href="#cb4-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-131"><a href="#cb4-131" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span>win_y, win_y, <span class="va">self</span>.max_stride):</span>
<span id="cb4-132"><a href="#cb4-132" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span>win_x, win_x, <span class="va">self</span>.max_stride):</span>
<span id="cb4-133"><a href="#cb4-133" aria-hidden="true" tabindex="-1"></a>                    append_node(x, y, t, <span class="va">self</span>.max_node_height, indices)</span>
<span id="cb4-134"><a href="#cb4-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-135"><a href="#cb4-135" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> node_queue:</span>
<span id="cb4-136"><a href="#cb4-136" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Get the node from the priority queue</span></span>
<span id="cb4-137"><a href="#cb4-137" aria-hidden="true" tabindex="-1"></a>            _, (x, y, t, height, indices, score) <span class="op">=</span> heapq.heappop(node_queue)</span>
<span id="cb4-138"><a href="#cb4-138" aria-hidden="true" tabindex="-1"></a>            num_processed <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb4-139"><a href="#cb4-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-140"><a href="#cb4-140" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> score <span class="op">&lt;=</span> best_score:</span>
<span id="cb4-141"><a href="#cb4-141" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Skip the node if the score is below the best score so far</span></span>
<span id="cb4-142"><a href="#cb4-142" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb4-143"><a href="#cb4-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-144"><a href="#cb4-144" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> height <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb4-145"><a href="#cb4-145" aria-hidden="true" tabindex="-1"></a>                <span class="co"># If the current node is a left, then update the solution</span></span>
<span id="cb4-146"><a href="#cb4-146" aria-hidden="true" tabindex="-1"></a>                best_x, best_y, best_theta, best_score <span class="op">=</span> x, y, t, score</span>
<span id="cb4-147"><a href="#cb4-147" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb4-148"><a href="#cb4-148" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Otherwise, split the current node into four new nodes</span></span>
<span id="cb4-149"><a href="#cb4-149" aria-hidden="true" tabindex="-1"></a>                new_x, new_y, new_height <span class="op">=</span> x, y, height <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb4-150"><a href="#cb4-150" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Compute a new stride</span></span>
<span id="cb4-151"><a href="#cb4-151" aria-hidden="true" tabindex="-1"></a>                s <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> new_height</span>
<span id="cb4-152"><a href="#cb4-152" aria-hidden="true" tabindex="-1"></a>                append_node(new_x, new_y, t, new_height, indices)</span>
<span id="cb4-153"><a href="#cb4-153" aria-hidden="true" tabindex="-1"></a>                append_node(new_x <span class="op">+</span> s, new_y, t, new_height, indices)</span>
<span id="cb4-154"><a href="#cb4-154" aria-hidden="true" tabindex="-1"></a>                append_node(new_x, new_y <span class="op">+</span> s, t, new_height, indices)</span>
<span id="cb4-155"><a href="#cb4-155" aria-hidden="true" tabindex="-1"></a>                append_node(new_x <span class="op">+</span> s, new_y <span class="op">+</span> s, t, new_height, indices)</span>
<span id="cb4-156"><a href="#cb4-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-157"><a href="#cb4-157" aria-hidden="true" tabindex="-1"></a>        best_pose <span class="op">=</span> Pose2D(initial_pose.x <span class="op">+</span> best_x <span class="op">*</span> step_x,</span>
<span id="cb4-158"><a href="#cb4-158" aria-hidden="true" tabindex="-1"></a>                           initial_pose.y <span class="op">+</span> best_y <span class="op">*</span> step_y,</span>
<span id="cb4-159"><a href="#cb4-159" aria-hidden="true" tabindex="-1"></a>                           initial_pose.theta <span class="op">+</span> best_theta <span class="op">*</span> step_theta)</span>
<span id="cb4-160"><a href="#cb4-160" aria-hidden="true" tabindex="-1"></a>        best_pose.theta <span class="op">=</span> wrap_angle(best_pose.theta)</span>
<span id="cb4-161"><a href="#cb4-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-162"><a href="#cb4-162" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> ScanMatcherBranchBound.Result(</span>
<span id="cb4-163"><a href="#cb4-163" aria-hidden="true" tabindex="-1"></a>            win, step, (best_x, best_y, best_theta), best_score,</span>
<span id="cb4-164"><a href="#cb4-164" aria-hidden="true" tabindex="-1"></a>            initial_pose, best_pose, num_solutions, num_processed)</span>
<span id="cb4-165"><a href="#cb4-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-166"><a href="#cb4-166" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> best_pose, result</span></code></pre></div>
<h2 id="分枝限定法によるスキャンマッチングの動作例">分枝限定法によるスキャンマッチングの動作例</h2>
<p>その他の実装は<a href="https://github.com/sterngerlach/scan_matcher_2d_python">GitHubのリポジトリ</a>を参照してください。 ここでは幾つかのデータセットを使った動作例を示します。 青色で示したスキャンは、姿勢の初期値を使って地図上に投影したものです(<code>match_scan()</code>メソッドの引数<code>initial_pose</code>)。 また赤色で示したスキャンは、姿勢の解を使って描画しています(<code>match_scan()</code>メソッドの変数<code>best_pose</code>)。</p>
<p>初期値と最適解がかなり大きく離れていますが、正しく動作していることが分かります。 ガウス・ニュートン法やレーベンバーグ・マーカート法などの、勾配を基にした逐次的なマッチング手法では、最適解への収束は期待できないでしょう。</p>
<ul>
<li>データセット7</li>
</ul>
<p><a href="slam-images/scan-matching-branch-and-bound/before-7.png"><img src="slam-images/scan-matching-branch-and-bound/before-7.png" width="320" /></a> <a href="slam-images/scan-matching-branch-and-bound/after-7.png"><img src="slam-images/scan-matching-branch-and-bound/after-7.png" width="320" /></a></p>
<ul>
<li>データセット8</li>
</ul>
<p><a href="slam-images/scan-matching-branch-and-bound/before-8.png"><img src="slam-images/scan-matching-branch-and-bound/before-8.png" width="320" /></a> <a href="slam-images/scan-matching-branch-and-bound/after-8.png"><img src="slam-images/scan-matching-branch-and-bound/after-8.png" width="320" /></a></p>
<ul>
<li>データセット18</li>
</ul>
<p><a href="slam-images/scan-matching-branch-and-bound/before-18.png"><img src="slam-images/scan-matching-branch-and-bound/before-18.png" width="320" /></a> <a href="slam-images/scan-matching-branch-and-bound/after-18.png"><img src="slam-images/scan-matching-branch-and-bound/after-18.png" width="320" /></a></p>
<ul>
<li>データセット25</li>
</ul>
<p><a href="slam-images/scan-matching-branch-and-bound/before-25.png"><img src="slam-images/scan-matching-branch-and-bound/before-25.png" width="320" /></a> <a href="slam-images/scan-matching-branch-and-bound/after-25.png"><img src="slam-images/scan-matching-branch-and-bound/after-25.png" width="320" /></a></p>
<ul>
<li>データセット32</li>
</ul>
<p><a href="slam-images/scan-matching-branch-and-bound/before-32.png"><img src="slam-images/scan-matching-branch-and-bound/before-32.png" width="320" /></a> <a href="slam-images/scan-matching-branch-and-bound/after-32.png"><img src="slam-images/scan-matching-branch-and-bound/after-32.png" width="320" /></a></p>
<p>データセット18の例では、探索範囲のサイズを<span class="math inline">\(25 \mathrm{m} \times 25 \mathrm{m} \times 0.2 \mathrm{rad}\)</span>、ステップサイズを<span class="math inline">\(0.05 \mathrm{m}, 0.0025 \mathrm{rad}\)</span>に設定しているので、20,000,000個もの解の候補が存在します。 しかし、分枝限定法で調べたノード数は11,252だったので(ノードの高さは最大6に設定)、解の候補のうちたったの0.056%を探索するだけで済んでいます。 言い換えると、全ての解の候補をしらみつぶしに調べる場合と比べて、1,777倍高速化されているということです。</p>
<p>これらを試すには、リポジトリ内の<code>main.py</code>を実行してください。 <code>main()</code>関数の先頭に書かれている変数<code>data_idx</code>は、データセットの番号(7、8、18、25、32のいずれか)を表します。 また変数<code>perturb_x</code>、<code>perturb_y</code>、<code>perturb_theta</code>は、初期値を最適解からどれだけ移動させるかを決定します。</p>
</body>
</html>
