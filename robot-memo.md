
---
title:  ロボットに関するメモ書き
author: SternGerlach
---

<!--
 pandoc -s --filter pandoc-crossref -M "crossrefYaml=./crossref_config.yaml" -f markdown -t html5 --mathjax --css style.css robot-memo.md > robot-memo.html
-->

# このページについて

情報工学実験第2のテーマ「知的ロボットインタフェースの製作」についてのメモが書かれています。

# ステッピングモータ

- ステッピングモータは、パルス状の電力によって動作する。モータの回転速度はパルスの周波数に比例し、入力パルス数に比例した角度だけ回転する。従って、フィードバック制御ではなく、フィードフォワード制御(オープンループ制御)によって位置決めの制御を行うことができる(他のモータでは必ずフィードバック制御が必要になる)。

- ステッピングモータは、低速回転時には減衰運動による振動が大きくなり、安定走行させられないことがある。高速回転時には滑らかに回転するため振動は少ない。

- ステッピングモータに加えるパルス数は、ロボットが移動したい距離から決定できる(ロボットの移動距離を1パルスで進む距離で割る)。パルス周波数($\mathrm{pps}$)の最適値は、ロボットの大きさと重さによって変わるので、実際に走行実験を行ってみて決定する。

- モータのオンとオフの時間の割合を変えることによってモータの速度を制御できる。

- モータをロボットの左右に配置し、各モータに車輪を取り付ける機構を採用することで、左右2輪速度差方式により制御できるようになる。左右2輪速度差方式を用いれば、左右車輪の回転速度を変えるだけで様々な運動を実現できる。直進(両輪の回転速度を等しくする)、左旋回(右輪の回転速度を左輪よりも大きくする)、右旋回(左輪の回転速度を右輪よりも大きくする)、信地旋回(片輪を停止させる)、極地旋回(左輪と右輪を逆方向に回転させる)などの運動である。

## ステッピングモータの加速方法

ステッピングモータを加減速させるためのパルス周波数は等加速近似曲線により決定できる。加速度を$\alpha$($\mathrm{pps/s}$)($\mathrm{pps}$はPulses Per Secondの略)、初速度を$f_0$($\mathrm{pps}$)、$t$秒後の速度を$f$($\mathrm{pps}$)とすると、等加速近似曲線は次のように表される。

$$f(t) = \alpha t + f_0 \qquad (\mathrm{pps})$$

これを時間積分すると、進んだ距離がパルス数$N$で得られる。

$$N = \int_{0}^{t} f(t) dt = \cfrac{1}{2} \alpha t^2 + f_0 t$$

上の2式から$t$を消去すると次のようになる。

$$f^2 - f_0^2 = 2 \alpha N$$

従って、$N$パルスで初速度$f_0$から最終速度$f_N$まで加速したときの加速度$\alpha$は、次のように求められる。

$$\alpha = \cfrac{f_N^2 - f_0^2}{2N} \qquad (\mathrm{pps/s})$$

$N = 1$のときのパルス周波数を$f_1$とすると

$$f_1 = \sqrt{f_0^2 + 2 \alpha} \qquad (\mathrm{pps})$$

また

$$f_1 = \alpha t_1 + f_0 \qquad (\mathrm{pps})$$

となるので、パルス周期$t_1$は

$$t_1 = \cfrac{f_1 - f_0}{\alpha} \qquad (\mathrm{s})$$

と求められる。$N = 2$のときのパルス周波数を$f_2$とすると

$$f_2 = \sqrt{f_0^2 + 2 \alpha \cdot 2} \qquad (\mathrm{pps})$$

また

$$f_2 = \alpha t_2 + f_1 \qquad (\mathrm{pps})$$

となるので、パルス周期$t_2$は

$$t_2 = \cfrac{f_2 - f_1}{\alpha} \qquad (\mathrm{s})$$

と求められる。$N$パルスのときのパルス周波数$f_N$とパルス周期$t_N$も上と同様に求められる。

$$f_N = \sqrt{f_0^2 + 2 \alpha N} \qquad (\mathrm{pps})$$
$$t_N = \cfrac{f_N - f_{N - 1}}{\alpha} \qquad (\mathrm{s})$$

時刻$t = 0$で最初のパルス、$t = t_1$で2番目のパルス、$t = t_1 + t_2$で3番目のパルスのように、パルス周期$t_N$に従ってパルスをモータに与えることで、等加速近似曲線に沿った加速を実現できる。

## ステッピングモータと移動距離の関係

ステッピングモータに車輪を取り付けたとき、車輪の移動距離$L$($\mathrm{m}$)は次のように求められる(車輪が滑らないとする)。1パルスで進む距離を$L'$($\mathrm{m}$)、モータに加える総パルス数を$N$とすると

$$L = L' \cdot N \qquad (\mathrm{m})$$

1パルスで進む距離$L'$は、モータの車軸に取り付けられた車輪の半径を$r$($\mathrm{m}$)、1ステップ角を$\theta$($\mathrm{deg}$)とすると

$$L' = \cfrac{\theta}{180^\circ} \pi r \qquad (\mathrm{m})$$

である。また、左右2輪速度差方式を用いて旋回を行うとき、モータの回転速度を一定に保てば、ロボットが移動する軌跡は円とみなすことができる。従って、モータに加えるパルス数は、車輪が通る軌跡の円弧の長さから求められる。

## ステッピングモータの等速運転

ステッピングモータを等速運転するためのプログラムを以下に擬似コードで示す。

```
    初期化処理;

    while (true) {
        パルスを出力;
        一定時間待つ;

        if (パルスを規定数出力した)
            break;
    }
```

## ステッピングモータの加減速(簡易版)

ステッピングモータを簡単に加減速するためのプログラムを以下に擬似コードで示す。原理は簡単で、パルスを出力するごとに、パルス周期を一定量だけ増減させるというものである。但し、パルス周期を一定量だけ小さくしていくと、パルス周波数は急激に増加して脱調が起こり易くなる。増減量を小さくして加速度を小さくする、目標速度を下げるなどの脱調しないための対策が必要となる。

```
    初期化処理;

    while (true) {
        パルスを出力;

        if (加速する)
            待つ時間を一定量減らす;
        else if (減速する)
            待つ時間を一定量増やす;
        else
            待つ時間はそのままとする;

        設定した時間だけ待つ;

        if (パルスを規定数出力した)
            break;
    }
```

## ステッピングモータの加減速

ステッピングモータを加減速するためのプログラムを以下に擬似コードで示す。上記の計算を行ってパルス周期を求めればよい。

```
    /* 初期化処理 */
    f_0 = (現在の速度);          /* パルス周波数の初期値 */
    alpha = (希望する加速度);    /* 希望する加速度 */
    f = 0;                      /* Nパルスのときのパルス周波数 */
    f_prev = f_0;               /* N - 1パルスのときのパルス周波数 */
    t = 0;                      /* Nパルスのときのパルス周期 */
    N = 0;                      /* 現在のパルス数 */

    while (true) {
        パルスを出力;
        N++;

        /* パルス周波数とパルス周期の計算 */
        f = sqrt(f_0 * f_0 + 2 * alpha * N);
        t = (f - f_prev) / alpha;
        f_prev = f;

        tだけ待つ;
        
        if (パルスを規定数出力した)
            break;
    }
```

# 障害物検知

障害物として検知した点$\textbf{p}_i$を、障害物までの距離$l_i$と方向$\theta_i$($i = 1, \cdots, n$)を用いて

$$\textbf{p}_i
= \left[ \begin{array}{c} x_i \\ y_i \end{array} \right]
= \left[ \begin{array}{c} l_i \cos \theta_i \\ l_i \sin \theta_i \end{array} \right]$$

と表す。$n$は検知できた点の総数とする。障害物がないときは最大検知半径$R$を用いて$l_i = R$とする。この点におけるポテンシャル関数$U_i(x, y)$を次のように表現する。

$$\begin{eqnarray} U_i(x, y) = \begin{cases}
\cfrac{1}{2} \eta \left( \cfrac{1}{\rho_i} - \cfrac{1}{\rho_0} \right)^2 &
(|\rho_i| \le \rho_0) \\
0 & (|\rho_i| > \rho_0)
\end{cases} \end{eqnarray}$$

$$\rho_i = \sqrt{(x - x_i)^2 + (y - y_i)^2}$$

ここで、$\eta$は正の定数、$\rho_0$はポテンシャル関数の値域を定めるためのパラメータで、いずれも障害物の検知感度を調整する役割がある。$U_i(x, y)$の上限値を$U_{\mathrm{max}}$で抑えるとする。点$(x, y)$におけるポテンシャルは、全ての点に対するポテンシャル関数$U_i(x, y)$の総和として求められる。

$$U(x, y) = \sum_{i = 1}^{n} U_i(x, y)$$
